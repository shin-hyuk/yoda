# YODA Documentation

                                ‚†Ä‚¢Ä‚£†‚£Ñ‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£¥‚£∂‚°æ‚†ø‚†ø‚†ø‚†ø‚¢∑‚£∂‚£¶‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚¢∞‚£ø‚°ü‚†õ‚†õ‚†õ‚†ª‚†ø‚†ø‚¢ø‚£∂‚£∂‚£¶‚£§‚£§‚£Ä‚£Ä‚°Ä‚£Ä‚£¥‚£æ‚°ø‚†ü‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†ª‚¢ø‚£∑‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä
                                ‚†Ä‚†ª‚£ø‚£¶‚°Ä‚†Ä‚†â‚†ì‚†∂‚¢¶‚£Ñ‚£Ä‚†â‚†â‚†õ‚†õ‚†ª‚†ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚£§‚°Ä‚†Ä‚†Ä‚¢†‚†Ä‚†Ä‚†Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†õ‚¢ª‚£ø
                                ‚†Ä‚†Ä‚†à‚†ª‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢∑‚£∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†ô‚¢∑‚°Ä‚†∏‚°á‚†Ä‚£∞‚†á‚†Ä‚¢Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£§‚£§‚£∂‚°∂‚†∂‚†∂‚†í‚†Ç‚†Ä‚†Ä‚£†‚£æ‚†ü
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚°Ñ‚£†‚£¥‚£ø‚£Ø‚£≠‚£Ω‚£∑‚£Ü‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£ø‚£¶‚°Ä‚†Ä‚£†‚£æ‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ü‚†Å‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ó‚¢ª‚£ø‚£ß‚£Ω‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚£Ä‚£Ä‚†Ä‚¢†‚£ø‚£ß‚£º‚£ø‚£ø‚£ø‚£ø‚†ó‚†∞‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£∂‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚†É‚†à‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†æ‚£•‚°¨‚†ó‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†Ä‚¢Ä‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†ø‚£∑‚£∂‚£§‚£§‚£Ñ‚£∞‚£Ñ‚†Ä‚†Ä‚†â‚†â‚†â‚†Å‚†Ä‚¢Ä‚£Ä‚£†‚£Ñ‚£Ä‚°Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£•‚£§‚£§‚£§‚£∂‚£∂‚°ø‚†ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢ª‚£ø‚†õ‚¢ø‚£∑‚£¶‚£§‚£¥‚£∂‚£∂‚£¶‚£§‚£§‚£§‚£§‚£¨‚£•‚°¥‚†∂‚†æ‚†ø‚†ø‚†ø‚†ø‚†õ‚¢õ‚£ø‚£ø‚£ø‚£Ø‚°â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ß‚°Ä‚†à‚†â‚†Ä‚†à‚†Å‚£æ‚†õ‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£ø‚†ü‚†â‚£π‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£∏‚£ø‚£ø‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£∂‚£ø‚†ã‚£ø‚†õ‚†É‚†Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚¢ø‚°Ä‚†à‚¢π‚°ø‚†∂‚£∂‚£º‚°á‚†Ä‚¢Ä‚£Ä‚£Ä‚£§‚£¥‚£æ‚†ü‚†ã‚£°‚£ø‚°ü‚†Ä‚¢ª‚£∂‚†∂‚£ø‚£ø‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£∑‚°à‚¢ø‚£¶‚£∏‚†á‚¢Ä‚°ø‚†ø‚†ø‚°ø‚†ø‚†ø‚£ø‚†õ‚†ã‚†Å‚†Ä‚£¥‚†ü‚£ø‚£ß‚°Ä‚†à‚¢Å‚£∞‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚¢ª‚£¶‚£à‚£Ω‚£Ä‚£æ‚†É‚†Ä‚¢∏‚°á‚†Ä‚¢∏‚°á‚†Ä‚¢Ä‚£†‚°æ‚†ã‚¢∞‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†ø‚¢ø‚£ø‚£ø‚°ü‚†õ‚†É‚†Ä‚†Ä‚£æ‚†Ä‚†Ä‚¢∏‚°á‚†ê‚†ø‚†ã‚†Ä‚†Ä‚£ø‚¢ª‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Å‚¢Ä‚°¥‚†ã‚†Ä‚£ø‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£Å‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†õ‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

## Overview

YODA is a Temporal-powered AI agent system for integrating external business tools via Model Context Protocol (MCP) servers. This document covers LLM-driven agent orchestration, team workflows, JWT authentication, MCP integration, and persistent alert/schedule systems.

### Architectural Traits

- **[MCP Servers for Tools](#mcp-servers-for-tools):** Modular tools, auto-discovered via NPM
- **[Parallel Team Workflow](#parallel-team-workflow):** Tool and goal teams work in parallel with minimal coordination
- **[Goal Switching Architecture](#goal-switching-architecture):** Users can seamlessly switch between agent personas and goals
- **[MCP Tool Documentation Standards](#mcp-tool-documentation-standards):** Standardized documentation for tool response schemas and examples alongside standard MCP protocol
- **[JWT-Based Authorization Flow](#jwt-based-authorization-flow):** User access is securely managed with JWT tokens across all tools
- **[Persistent Alerts & Schedules](#persistent-alerts--schedules):** User-specific alerts and schedules are managed as stateful JSON feeds within the orchestrator

**Note:** All file paths and package names mentioned in this document are exact locations used in the codebase. Tool and goal teams only need to update these specific files and packages to register new tools, define agent goals, or integrate new business logic as described below. Note that "goal" and "agent" are used interchangeably throughout this document.

---

## MCP Servers for Tools

YODA's architecture is modular by design: YODA itself acts as the orchestrator ("the brain"), while all business logic and integrations are provided by independently developed MCP servers ("the hands"). MCP servers expose tools without needing to know anything about the orchestrator's internals, enabling infinite scalability and rapid, parallel development.

### Tool Registration & Deployment

1. Publish MCP server to NPM
2. Register server endpoint in the orchestrator
3. Reference server in goal files
4. Tools are auto-discovered at runtime

**Note:** For the exact file paths, code references, and detailed step-by-step process, see the [Parallel Team Workflow](#parallel-team-workflow) section.

```mermaid
graph TB
    User["<b>User Input</b>"] --> Frontend["<b>React Frontend</b><br/><i>localhost:5173</i>"]
    Frontend --> API["<b>FastAPI Server</b><br/><i>localhost:8000</i>"]
    API --> Temporal["<b>Temporal Server</b><br/><i>localhost:7233</i>"]
    
    subgraph YodaBrain ["üß† <b>YODA - The Orchestrator Brain</b>"]
        Temporal --> Worker["<b>Temporal Worker</b>"]
        Worker --> AgentWorkflow["<b>AgentGoalWorkflow</b><br/><i>workflows/agent_goal_workflow.py</i>"]
        AgentWorkflow --> LLMActivity["<b>LLM Activities</b><br/><i>activities/tool_activities.py</i>"]
        AgentWorkflow --> MCPClientManager["<b>MCP Client Manager</b><br/><i>shared/mcp_client_manager.py</i>"]
        MCPClientManager --> RuntimeDiscovery["<b>Runtime Tool Discovery</b><br/><i>mcp_list_tools activity</i>"]
    end
    
    subgraph ExternalMCP ["üåê <b>External MCP Ecosystem</b>"]
        BusinessAPI["<b>Business API</b><br/><i>npx @company/business-mcp</i>"]
        AnalyticsService["<b>Analytics Service</b><br/><i>npx @company/analytics-mcp</i>"]
        IntegrationHub["<b>Integration Hub</b><br/><i>npx @company/integration-mcp</i>"]
    end
    
    subgraph Infrastructure ["üèóÔ∏è <b>Infrastructure</b>"]
        Postgres[("<b>PostgreSQL</b><br/><i>Temporal Persistence</i>")]
        NPMRegistry[("<b>NPM Registry</b><br/><i>MCP Package Distribution</i>")]
    end
    
    %% Connections
    MCPClientManager --> BusinessAPI
    MCPClientManager --> AnalyticsService  
    MCPClientManager --> IntegrationHub
    BusinessAPI -.->|Discovery| RuntimeDiscovery
    AnalyticsService -.->|Discovery| RuntimeDiscovery
    IntegrationHub -.->|Discovery| RuntimeDiscovery
    Temporal --> Postgres
    ExternalMCP --> NPMRegistry
    
    classDef brain fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef infra fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YodaBrain brain
    class ExternalMCP external
    class Infrastructure infra
```

## **MCP Tool Documentation Standards**

YODA's scalable tool ecosystem is built on close collaboration between two teams: **tool teams**, who develop and maintain MCP servers, and **goal teams**, who design agent experiences that leverage those tools. The standard MCP protocol exposes only a tool's name, description, and input schema‚Äîleaving goal teams to infer or reverse-engineer response formats.

To solve this, YODA establishes a shared documentation standard: both teams collaborate on a living document that clearly defines response schemas and example payloads. This document acts first as a requirements spec from the goal team, then as the authoritative reference from the tool team, ensuring agent design is accurate and tool integration is seamless.

**Example: Documentation Standard in Practice**

```markdown
# @company/customer-mcp-server Documentation

## GetCustomerDetails Tool

**Summary:**
Retrieves detailed customer information from the CRM system. Returns customer profile data including contact information, account status, and registration details.

**Input Schema:**
{
    "type": "object",
    "properties": {
    "customer_id": {"type": "string", "description": "Unique customer identifier"}
    },
    "required": ["customer_id"]
  }

**Response Schema:**
{
  "type": "object", 
  "properties": {
    "customer_id": {"type": "string"},
    "name": {"type": "string"},
    "email": {"type": "string"},
    "status": {"type": "string"},
    "created_date": {"type": "string", "format": "date"}
  },
  "required": ["customer_id", "name", "email", "status"]
}

**Examples:**
- Success: {"customer_id": "CUST_123", "name": "John Smith", "email": "john@example.com", "status": "active", "created_date": "2024-01-15"}
- Not Found: {"error": "Customer not found", "customer_id": "CUST_999"}
```

---

## Streamlined Team Workflow

1. **Goal Team: Define & Send Requirement**  
   Prepare a structured MCP server/tool requirement document (as shown in the documentation standards above).

2. **Tool Team: Develop & Document**  
   Implement the MCP server and tools based on the requirement, update shared documentation with finalized response schemas and examples, then publish to NPM.

3. **Goal Team: Integrate & Design**  
   Add the server definition to the orchestrator, reference it in goal files, and use the documentation to write accurate `example_conversation_history` for agent behavior.

```python
# Goal team uses finalized documentation to write accurate tool responses:
example_conversation_history="\n ".join([
    "user_confirmed_tool_run: <user clicks confirm on GetCustomerDetails tool>",
    "tool_result: { 'customer_id': 'CUST_123', 'name': 'John Smith', 'email': 'john@example.com', 'status': 'active' }",  # From tool docs
    "agent: Found customer John Smith (john@example.com) - account is active."
])
```

---

## **Goal Switching Architecture**

Original Temporal supports both single-agent and multi-agent modes, but YODA defaults to multi-goal mode‚Äîenabling agent orchestration and fully realizing the MCP framework.

```mermaid
graph TD
    subgraph AnyGoal ["Any Active Goal (Travel, HR, Finance, etc.)"]
        direction TB
        UserInGoal[User in Middle of Goal<br/>e.g., Booking Flights]
        GoalTools[Goal-Specific Tools<br/>+ ListAgents tool<br/>auto-added in multi-goal mode]
        
        UserInGoal --> GoalTools
    end
    
    subgraph TwoEscapeRoutes ["Two Escape Routes from Any Goal"]
        direction TB
        
        subgraph Route1 ["Route 1: Natural Completion"]
            direction TB
            CompleteAllSteps[Complete ALL Goal Steps<br/>e.g., Search ‚Üí Book ‚Üí Invoice]
            SystemTrigger[System Triggers<br/>'pick-new-goal']
            AutoReturn[Auto-Return to<br/>goal_choose_agent_type]
            
            CompleteAllSteps --> SystemTrigger
            SystemTrigger --> AutoReturn
        end
        
        subgraph Route2 ["Route 2: Instant Switch"]
            direction TB
            UserCallsListAgents[User Calls ListAgents<br/>from any goal]
            InstantJump[Instant Jump to<br/>goal_choose_agent_type]
            ChangeGoalAvailable[ChangeGoal Tool<br/>Now Available]
            
            UserCallsListAgents --> InstantJump
            InstantJump --> ChangeGoalAvailable
        end
    end
    
    subgraph AgentSelection ["Agent Selection Hub (goal_choose_agent_type)"]
        direction TB
        ListAgentsSilent[ListAgents Runs Silently<br/>Shows All Available Agents]
        ChangeGoalTool[ChangeGoal Tool Available<br/>Can Switch to ANY Goal]
        NewGoalSelected[User Selects New Goal<br/>e.g., HR, Finance, Travel]
        
        ListAgentsSilent --> ChangeGoalTool
        ChangeGoalTool --> NewGoalSelected
    end
    
    %% Connections
    GoalTools -->|Route 1| Route1
    GoalTools -->|Route 2| Route2
    AutoReturn --> AgentSelection
    ChangeGoalAvailable --> AgentSelection
    NewGoalSelected --> AnyGoal
    
    classDef anyGoal fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef route1 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef route2 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef agentHub fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class AnyGoal anyGoal
    class Route1 route1
    class Route2 route2
    class AgentSelection agentHub
```



---

## **Backend Infrastructure MCP Servers**

YODA distinguishes between business logic MCP servers and backend infrastructure MCP servers. Backend infrastructure MCP servers fall into two categories: **orchestrator-level MCP servers** used internally by the orchestrator for platform-specific backend operations (authentication, user scoping, system management), and **support backend MCP servers** used by business MCP servers to provide universal features like alerts, scheduling, notifications, and analytics.

YODA's backend infrastructure is organized into two tiers: the orchestrator interacts with platform-specific MCP servers for internal backend needs, while business MCP servers interact with support backend MCP servers to access shared infrastructure features.

```mermaid
graph TD
    subgraph YODA ["üß† YODA Orchestrator"]
        ListAgents["Enhanced ListAgents<br/>scope-aware filtering"]
        Workflow["AgentGoalWorkflow<br/>user scope management"]
    end
    
    subgraph OrchMCP ["üîê Orchestrator-Level MCP Servers"]
        PortalAuth["@portal/auth-mcp<br/>Portal JWT ‚Üí roles"]
        AppAuth["@app/auth-mcp<br/>App JWT ‚Üí roles"] 
        EnterpriseAuth["@enterprise/auth-mcp<br/>SSO JWT ‚Üí roles"]
    end
    
    subgraph SupportMCP ["üîß Support Backend MCP Servers"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert<br/>GetUserAlerts"]
        ScheduleMCP["@yoda/scheduler-mcp<br/>CreateSchedule<br/>GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail<br/>SendSMS"]
        AnalyticsMCP["@yoda/analytics-mcp<br/>TrackEvent<br/>GetMetrics"]
    end
    
    subgraph GoalMCP ["üè¢ Goal-Oriented MCP Servers"]
        CustomerMCP["@company/customer-mcp<br/>GetCustomerDetails<br/>UpdateCustomer"]
        FinanceMCP["@company/finance-mcp<br/>TransferMoney<br/>GetBalance"]
        HRMCP["@company/hr-mcp<br/>BookPTO<br/>GetPayroll"]
    end
    
    %% Orchestrator uses orchestrator-level MCP servers
    YODA --> PortalAuth
    YODA --> AppAuth  
    YODA --> EnterpriseAuth
    
    %% Goal-oriented MCP servers use support backend MCP servers
    CustomerMCP --> AlertsMCP
    CustomerMCP --> NotificationMCP
    FinanceMCP --> AlertsMCP
    FinanceMCP --> ScheduleMCP
    HRMCP --> ScheduleMCP
    HRMCP --> AnalyticsMCP
    
    classDef orch fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef orchMCP fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef supportMCP fill:#e8eaf6,stroke:#3f51b5,stroke-width:2px
    classDef goalMCP fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YODA orch
    class OrchMCP orchMCP
    class SupportMCP supportMCP
    class GoalMCP goalMCP
```



### **Orchestrator-Level MCP Servers**

Orchestrator-level MCP servers are only used by the YODA orchestrator for internal backend operations. Examples: **@portal/auth-mcp** (maps portal JWTs to user roles), **@app/auth-mcp** (maps mobile app JWTs to user roles), **@enterprise/auth-mcp** (maps enterprise SSO to user roles). All return a standardized user context for downstream use.

### **Support Backend MCP Servers**

Support backend MCP servers provide universal infrastructure features to all business MCP servers. Examples: **@yoda/alerts-mcp** (alerts and notifications), **@yoda/scheduler-mcp** (scheduling and automation), **@yoda/notification-mcp** (multi-channel notifications), **@yoda/analytics-mcp** (analytics and event tracking). These servers are platform-agnostic and can be used by any business logic MCP server.

---

## **Platform-Specific Auth Tools**

YODA uses the appropriate platform authentication MCP server to handle JWT complexity and map platform-specific authentication to clean, standardized user roles. This enables scope-aware agent discovery where each user role (client, csr, ops, sales) has dedicated agent goals with tailored behaviors and conversation styles.

```mermaid
graph TD
    subgraph Frontend ["üåê Frontend (Embedded in Portal)"]
        PortalSession["Portal Session<br/>sessionId: abc123"]
        YodaUI["YODA Chat UI<br/>React Component"]
        PortalSession --> YodaUI
    end
    
    subgraph YODA ["üß† YODA Orchestrator"]
        API["FastAPI<br/>/send-prompt + sessionId"]
        Workflow["AgentGoalWorkflow<br/>role-aware processing"]
        ListAgents["Enhanced ListAgents Tool<br/>scope-aware filtering"]
        
        API --> Workflow
        Workflow --> ListAgents
    end
    
    subgraph AuthMCP ["üîê Platform-Specific Auth MCP Servers"]
        PortalAuthMCP["@portal/auth-mcp<br/>Portal JWT ‚Üí role_categories"]
        AppAuthMCP["@app/auth-mcp<br/>App JWT ‚Üí role_categories"] 
        EnterpriseAuthMCP["@enterprise/auth-mcp<br/>SSO JWT ‚Üí role_categories"]
    end
    
    subgraph Goals ["üìÅ Role-Based Goal Categories"]
        ClientGoals["client.py<br/>Friendly conversation style"]
        CSRGoals["csr.py<br/>Professional support style"] 
        OpsGoals["ops.py<br/>Direct technical reports"]
        SalesGoals["sales.py<br/>Relationship-focused style"]
        
        ClientGoals --> SameTools["Same Business Tools<br/>Different Agent Behaviors"]
        CSRGoals --> SameTools
        OpsGoals --> SameTools
        SalesGoals --> SameTools
    end
    
    subgraph SupportMCP ["üîß Support Backend MCP Servers"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert, GetAlerts"]
        SchedulerMCP["@yoda/scheduler-mcp<br/>CreateSchedule, GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail, SendSMS"]
    end
    
    %% Flow connections
    YodaUI -->|"{ prompt, sessionId }"| API
    ListAgents --> PortalAuthMCP
    PortalAuthMCP -->|"role_categories: ['csr']"| ListAgents
    ListAgents -->|"filtered agents by role"| Workflow
    Goals -->|"agents with tailored behaviors"| ListAgents
    SameTools --> SupportMCP
    
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef yoda fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef auth fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef goals fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef support fill:#e8eaf6,stroke:#3f51b5,stroke-width:2px
    
    class Frontend frontend
    class YODA yoda
    class AuthMCP auth
    class Goals goals
    class SupportMCP support
```

Each user role (client, csr, ops, sales) is mapped to a dedicated agent goal with a tailored conversation style, even when using the same underlying tools. Goal teams define these behaviors by writing the `example_conversation_history` for each agent:

```python
# Goal team defines role-specific agent behavior
goal_csr_order_status = AgentGoal(
    category_tag="csr",
    example_conversation_history="\n ".join([
        "user: Order status for 102",
        "agent: Order ID: 102. Status: Shipped. Tracking: 039813852990618. ETA: April 30, 2025."
    ])
)

goal_client_order_status = AgentGoal(
    category_tag="client", 
    example_conversation_history="\n ".join([
        "user: Hi, how's my order doing?",
        "agent: Hi there! I'd be happy to check on your order. What's your order number?",
        "user: 102",
        "agent: Great news! Your order shipped and is on its way! üòä"
    ])
)
```



---

## **Support Backend MCP Servers in Action**

Support backend MCP servers are used by business MCP servers from any domain (finance, HR, customer service) to access shared infrastructure features:

- **Alerts:** `await alerts_mcp.create_user_alert(condition="BTC < $50000")`
- **Scheduling:** `await scheduler_mcp.create_schedule(action="process_payroll", condition="bi_weekly")`
- **Notifications:** `await notification_mcp.send_email(template="confirmation")`
- **Analytics:** `await analytics_mcp.track_event(event="money_transfer")`


