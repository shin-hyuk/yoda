# YODA Documentation

                                ‚†Ä‚¢Ä‚£†‚£Ñ‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£¥‚£∂‚°æ‚†ø‚†ø‚†ø‚†ø‚¢∑‚£∂‚£¶‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚¢∞‚£ø‚°ü‚†õ‚†õ‚†õ‚†ª‚†ø‚†ø‚¢ø‚£∂‚£∂‚£¶‚£§‚£§‚£Ä‚£Ä‚°Ä‚£Ä‚£¥‚£æ‚°ø‚†ü‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†ª‚¢ø‚£∑‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä
                                ‚†Ä‚†ª‚£ø‚£¶‚°Ä‚†Ä‚†â‚†ì‚†∂‚¢¶‚£Ñ‚£Ä‚†â‚†â‚†õ‚†õ‚†ª‚†ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚£§‚°Ä‚†Ä‚†Ä‚¢†‚†Ä‚†Ä‚†Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†õ‚¢ª‚£ø
                                ‚†Ä‚†Ä‚†à‚†ª‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢∑‚£∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†ô‚¢∑‚°Ä‚†∏‚°á‚†Ä‚£∞‚†á‚†Ä‚¢Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£§‚£§‚£∂‚°∂‚†∂‚†∂‚†í‚†Ç‚†Ä‚†Ä‚£†‚£æ‚†ü
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚°Ñ‚£†‚£¥‚£ø‚£Ø‚£≠‚£Ω‚£∑‚£Ü‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£ø‚£¶‚°Ä‚†Ä‚£†‚£æ‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ü‚†Å‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ó‚¢ª‚£ø‚£ß‚£Ω‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚£Ä‚£Ä‚†Ä‚¢†‚£ø‚£ß‚£º‚£ø‚£ø‚£ø‚£ø‚†ó‚†∞‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£∂‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚†É‚†à‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†æ‚£•‚°¨‚†ó‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†Ä‚¢Ä‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†ø‚£∑‚£∂‚£§‚£§‚£Ñ‚£∞‚£Ñ‚†Ä‚†Ä‚†â‚†â‚†â‚†Å‚†Ä‚¢Ä‚£Ä‚£†‚£Ñ‚£Ä‚°Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£•‚£§‚£§‚£§‚£∂‚£∂‚°ø‚†ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢ª‚£ø‚†õ‚¢ø‚£∑‚£¶‚£§‚£¥‚£∂‚£∂‚£¶‚£§‚£§‚£§‚£§‚£¨‚£•‚°¥‚†∂‚†æ‚†ø‚†ø‚†ø‚†ø‚†õ‚¢õ‚£ø‚£ø‚£ø‚£Ø‚°â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ß‚°Ä‚†à‚†â‚†Ä‚†à‚†Å‚£æ‚†õ‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£ø‚†ü‚†â‚£π‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£∏‚£ø‚£ø‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£∂‚£ø‚†ã‚£ø‚†õ‚†É‚†Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚¢ø‚°Ä‚†à‚¢π‚°ø‚†∂‚£∂‚£º‚°á‚†Ä‚¢Ä‚£Ä‚£Ä‚£§‚£¥‚£æ‚†ü‚†ã‚£°‚£ø‚°ü‚†Ä‚¢ª‚£∂‚†∂‚£ø‚£ø‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£∑‚°à‚¢ø‚£¶‚£∏‚†á‚¢Ä‚°ø‚†ø‚†ø‚°ø‚†ø‚†ø‚£ø‚†õ‚†ã‚†Å‚†Ä‚£¥‚†ü‚£ø‚£ß‚°Ä‚†à‚¢Å‚£∞‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚¢ª‚£¶‚£à‚£Ω‚£Ä‚£æ‚†É‚†Ä‚¢∏‚°á‚†Ä‚¢∏‚°á‚†Ä‚¢Ä‚£†‚°æ‚†ã‚¢∞‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†ø‚¢ø‚£ø‚£ø‚°ü‚†õ‚†É‚†Ä‚†Ä‚£æ‚†Ä‚†Ä‚¢∏‚°á‚†ê‚†ø‚†ã‚†Ä‚†Ä‚£ø‚¢ª‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Å‚¢Ä‚°¥‚†ã‚†Ä‚£ø‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£Å‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†õ‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

## Overview

YODA is a Temporal-powered AI agent system for integrating external business tools via Model Context Protocol (MCP) servers. This document covers LLM-driven agent orchestration, team workflows, JWT authentication, MCP integration, and persistent alert/schedule systems.

### Architectural Traits

- **[MCP Servers for Tools](#mcp-servers-for-tools):** Modular tools, auto-discovered via NPM
- **[Parallel Team Workflow](#parallel-team-workflow):** Tool and goal teams work in parallel with minimal coordination
- **[Goal Switching Architecture](#goal-switching-architecture):** Users can seamlessly switch between agent personas and goals
- **[MCP Tool Documentation Standards](#mcp-tool-documentation-standards):** Standardized documentation for tool response schemas and examples alongside standard MCP protocol
- **[JWT-Based Authorization Flow](#jwt-based-authorization-flow):** User access is securely managed with JWT tokens across all tools
- **[Persistent Alerts & Schedules](#persistent-alerts--schedules):** User-specific alerts and schedules are managed as stateful JSON feeds within the orchestrator

**Note:** All file paths and package names mentioned in this document are exact locations used in the codebase. Tool and goal teams only need to update these specific files and packages to register new tools, define agent goals, or integrate new business logic as described below. Note that "goal" and "agent" are used interchangeably throughout this document.

---

## MCP Servers for Tools

YODA's architecture is modular by design: YODA itself acts as the orchestrator ("the brain"), while all business logic and integrations are provided by independently developed MCP servers ("the hands"). MCP servers expose tools without needing to know anything about the orchestrator's internals, enabling infinite scalability and rapid, parallel development.

### Tool Registration & Deployment

1. Publish MCP server to NPM
2. Register server endpoint in the orchestrator
3. Reference server in goal files
4. Tools are auto-discovered at runtime

**Note:** For the exact file paths, code references, and detailed step-by-step process, see the [Parallel Team Workflow](#parallel-team-workflow) section.

```mermaid
graph TB
    User["<b>User Input</b>"] --> Frontend["<b>React Frontend</b><br/><i>localhost:5173</i>"]
    Frontend --> API["<b>FastAPI Server</b><br/><i>localhost:8000</i>"]
    API --> Temporal["<b>Temporal Server</b><br/><i>localhost:7233</i>"]
    
    subgraph YodaBrain ["üß† <b>YODA - The Orchestrator Brain</b>"]
        Temporal --> Worker["<b>Temporal Worker</b>"]
        Worker --> AgentWorkflow["<b>AgentGoalWorkflow</b><br/><i>workflows/agent_goal_workflow.py</i>"]
        AgentWorkflow --> LLMActivity["<b>LLM Activities</b><br/><i>activities/tool_activities.py</i>"]
        AgentWorkflow --> MCPClientManager["<b>MCP Client Manager</b><br/><i>shared/mcp_client_manager.py</i>"]
        MCPClientManager --> RuntimeDiscovery["<b>Runtime Tool Discovery</b><br/><i>mcp_list_tools activity</i>"]
    end
    
    subgraph ExternalMCP ["üåê <b>External MCP Ecosystem</b>"]
        BusinessAPI["<b>Business API</b><br/><i>npx @company/business-mcp</i>"]
        AnalyticsService["<b>Analytics Service</b><br/><i>npx @company/analytics-mcp</i>"]
        IntegrationHub["<b>Integration Hub</b><br/><i>npx @company/integration-mcp</i>"]
    end
    
    subgraph Infrastructure ["üèóÔ∏è <b>Infrastructure</b>"]
        Postgres[("<b>PostgreSQL</b><br/><i>Temporal Persistence</i>")]
        NPMRegistry[("<b>NPM Registry</b><br/><i>MCP Package Distribution</i>")]
    end
    
    %% Connections
    MCPClientManager --> BusinessAPI
    MCPClientManager --> AnalyticsService  
    MCPClientManager --> IntegrationHub
    BusinessAPI -.->|Discovery| RuntimeDiscovery
    AnalyticsService -.->|Discovery| RuntimeDiscovery
    IntegrationHub -.->|Discovery| RuntimeDiscovery
    Temporal --> Postgres
    ExternalMCP --> NPMRegistry
    
    classDef brain fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef infra fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YodaBrain brain
    class ExternalMCP external
    class Infrastructure infra
```

## **MCP Tool Documentation Standards**

YODA's scalable tool ecosystem is built on close collaboration between two teams: **tool teams**, who develop and maintain MCP servers, and **goal teams**, who design agent experiences that leverage those tools. The standard MCP protocol exposes only a tool's name, description, and input schema‚Äîleaving goal teams to infer or reverse-engineer response formats.

To solve this, YODA establishes a shared documentation standard: both teams collaborate on a living document that clearly defines response schemas and example payloads. This document acts first as a requirements spec from the goal team, then as the authoritative reference from the tool team, ensuring agent design is accurate and tool integration is seamless.

**Example: Documentation Standard in Practice**

```markdown
# @company/customer-mcp-server Documentation

## GetCustomerDetails Tool

**Summary:**
Retrieves detailed customer information from the CRM system. Returns customer profile data including contact information, account status, and registration details.

**Input Schema:**
{
    "type": "object",
    "properties": {
    "customer_id": {"type": "string", "description": "Unique customer identifier"}
    },
    "required": ["customer_id"]
  }

**Response Schema:**
{
  "type": "object", 
  "properties": {
    "customer_id": {"type": "string"},
    "name": {"type": "string"},
    "email": {"type": "string"},
    "status": {"type": "string"},
    "created_date": {"type": "string", "format": "date"}
  },
  "required": ["customer_id", "name", "email", "status"]
}

**Examples:**
- Success: {"customer_id": "CUST_123", "name": "John Smith", "email": "john@example.com", "status": "active", "created_date": "2024-01-15"}
- Not Found: {"error": "Customer not found", "customer_id": "CUST_999"}
```

---

## Streamlined Team Workflow

1. **Goal Team: Define & Send Requirement**  
   Prepare a structured MCP server/tool requirement document (as shown in the documentation standards above).

2. **Tool Team: Develop & Document**  
   Implement the MCP server and tools based on the requirement, update shared documentation with finalized response schemas and examples, then publish to NPM.

3. **Goal Team: Integrate & Design**  
   Add the server definition to the orchestrator, reference it in goal files, and use the documentation to write accurate `example_conversation_history` for agent behavior.

```python
# Goal team uses finalized documentation to write accurate tool responses:
example_conversation_history="\n ".join([
    "user_confirmed_tool_run: <user clicks confirm on GetCustomerDetails tool>",
    "tool_result: { 'customer_id': 'CUST_123', 'name': 'John Smith', 'email': 'john@example.com', 'status': 'active' }",  # From tool docs
    "agent: Found customer John Smith (john@example.com) - account is active."
])
```

---

## **Goal Switching Architecture**

Original Temporal supports both single-agent and multi-agent modes, but YODA defaults to multi-goal mode‚Äîenabling agent orchestration and fully realizing the MCP framework.

```mermaid
graph TD
    subgraph AnyGoal ["Any Active Goal (Travel, HR, Finance, etc.)"]
        direction TB
        UserInGoal[User in Middle of Goal<br/>e.g., Booking Flights]
        GoalTools[Goal-Specific Tools<br/>+ ListAgents tool<br/>auto-added in multi-goal mode]
        
        UserInGoal --> GoalTools
    end
    
    subgraph TwoEscapeRoutes ["Two Escape Routes from Any Goal"]
        direction TB
        
        subgraph Route1 ["Route 1: Natural Completion"]
            direction TB
            CompleteAllSteps[Complete ALL Goal Steps<br/>e.g., Search ‚Üí Book ‚Üí Invoice]
            SystemTrigger[System Triggers<br/>'pick-new-goal']
            AutoReturn[Auto-Return to<br/>goal_choose_agent_type]
            
            CompleteAllSteps --> SystemTrigger
            SystemTrigger --> AutoReturn
        end
        
        subgraph Route2 ["Route 2: Instant Switch"]
            direction TB
            UserCallsListAgents[User Calls ListAgents<br/>from any goal]
            InstantJump[Instant Jump to<br/>goal_choose_agent_type]
            ChangeGoalAvailable[ChangeGoal Tool<br/>Now Available]
            
            UserCallsListAgents --> InstantJump
            InstantJump --> ChangeGoalAvailable
        end
    end
    
    subgraph AgentSelection ["Agent Selection Hub (goal_choose_agent_type)"]
        direction TB
        ListAgentsSilent[ListAgents Runs Silently<br/>Shows All Available Agents]
        ChangeGoalTool[ChangeGoal Tool Available<br/>Can Switch to ANY Goal]
        NewGoalSelected[User Selects New Goal<br/>e.g., HR, Finance, Travel]
        
        ListAgentsSilent --> ChangeGoalTool
        ChangeGoalTool --> NewGoalSelected
    end
    
    %% Connections
    GoalTools -->|Route 1| Route1
    GoalTools -->|Route 2| Route2
    AutoReturn --> AgentSelection
    ChangeGoalAvailable --> AgentSelection
    NewGoalSelected --> AnyGoal
    
    classDef anyGoal fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef route1 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef route2 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef agentHub fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class AnyGoal anyGoal
    class Route1 route1
    class Route2 route2
    class AgentSelection agentHub
```



---

## **Backend Infrastructure Tools**

YODA's architecture separates **goal-oriented tools** (business logic for user interactions) from **backend infrastructure tools** (system capabilities like authentication, permissions, alerts). Backend tools are implemented as MCP servers that goal-oriented tools consume, creating a composable microservices architecture where any business tool can leverage system capabilities.

### **Architecture Pattern: Infrastructure as MCP Tools**

```mermaid
graph TD
    subgraph "Goal-Oriented Tools" 
        CustomerMCP["@company/customer-mcp<br/>GetCustomerDetails<br/>UpdateCustomer"]
        FinanceMCP["@company/finance-mcp<br/>TransferMoney<br/>GetBalance"]
        HRMCP["@company/hr-mcp<br/>BookPTO<br/>GetPayroll"]
    end
    
    subgraph "Backend Infrastructure Tools"
        UserMgmtMCP["@yoda/user-management-mcp<br/>AuthenticateUser<br/>ValidatePermissions"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert<br/>GetUserAlerts"]
        ScheduleMCP["@yoda/scheduler-mcp<br/>CreateSchedule<br/>GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail<br/>SendSMS"]
    end
    
    CustomerMCP --> UserMgmtMCP
    CustomerMCP --> AlertsMCP
    FinanceMCP --> UserMgmtMCP
    FinanceMCP --> AlertsMCP
    FinanceMCP --> NotificationMCP
    HRMCP --> UserMgmtMCP
    HRMCP --> ScheduleMCP
    
    UserMgmtMCP --> Database["PostgreSQL<br/>users, sessions, permissions"]
    AlertsMCP --> Database
    ScheduleMCP --> Database
```

### **Benefits of Backend Tool Architecture**

- **üîß Composable Microservices:** Any goal-oriented tool can use any backend capability
- **üéØ Separation of Concerns:** User-facing business logic separate from infrastructure logic
- **‚ôªÔ∏è Reusability:** Backend tools shared across all business domains
- **üß™ Testability:** Each infrastructure capability independently testable
- **üìà Scalability:** Backend tools can be scaled independently based on usage

### **Example: Rich Business Tool Using Backend Infrastructure**

```python
# @company/finance-mcp-server leveraging backend tools
class FinanceMCP:
    def __init__(self):
        self.user_mgmt = MCPClient("@yoda/user-management-mcp")
        self.alerts = MCPClient("@yoda/alerts-mcp")
        self.notifications = MCPClient("@yoda/notification-mcp")
    
    async def transfer_money(self, from_account, to_account, amount, user_id):
        # 1. Validate permissions using backend tool
        has_permission = await self.user_mgmt.validate_permissions(
            user_id=user_id,
            required_scopes=["ops"]
        )
        
        if not has_permission:
            return {"error": "Insufficient permissions"}
        
        # 2. Business logic
        transfer = await self.execute_transfer(from_account, to_account, amount)
        
        # 3. Create alert using backend tool
        if amount > 10000:
            await self.alerts.create_user_alert(
                user_id=user_id,
                condition=f"Large transfer of ${amount:,.2f} completed",
                alert_type="high_value_transaction"
            )
        
        # 4. Send notification using backend tool
        await self.notifications.send_email(
            user_id=user_id,
            template="transfer_confirmation",
            data={"amount": amount, "to_account": to_account}
        )
        
        return {"transfer_id": transfer.id, "status": "completed"}
```

---

## **User Management & Authentication Flow**

YODA implements scope-based agent categories where each user role (client, csr, ops, sales) has dedicated agent goals with tailored behaviors and conversation styles. The system uses a single authentication MCP server to handle JWT complexity and map enterprise authentication to clean role categories, with the `listAgents` tool providing scope-aware agent discovery.

```mermaid
graph TD
    subgraph Frontend ["üåê Frontend (Embedded in Portal)"]
        PortalSession["Portal Session<br/>sessionId: abc123"]
        YodaUI["YODA Chat UI<br/>React Component"]
        PortalSession --> YodaUI
    end
    
    subgraph YODA ["üß† YODA Orchestrator"]
        API["FastAPI<br/>/send-prompt + sessionId"]
        Workflow["AgentGoalWorkflow<br/>role-aware processing"]
        ListAgents["Enhanced ListAgents Tool<br/>scope-aware filtering"]
        
        API --> Workflow
        Workflow --> ListAgents
    end
    
    subgraph AuthMCP ["üîê @entity/auth-mcp-server"]
        AuthTool["AuthenticateUser<br/>sessionId ‚Üí role_categories"]
        JWTMapping["JWT Complexity Handler<br/>enterprise JWT ‚Üí clean roles"]
        
        AuthTool --> JWTMapping
    end
    
    subgraph Goals ["üìÅ Role-Based Goal Categories"]
        ClientGoals["client.py<br/>Friendly conversation style"]
        CSRGoals["csr.py<br/>Professional support style"] 
        OpsGoals["ops.py<br/>Direct technical reports"]
        SalesGoals["sales.py<br/>Relationship-focused style"]
        
        ClientGoals --> SameTools["Same Business Tools<br/>Different Agent Behaviors"]
        CSRGoals --> SameTools
        OpsGoals --> SameTools
        SalesGoals --> SameTools
    end
    
    subgraph BackendInfra ["üîß Backend Infrastructure Tools"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert, GetAlerts"]
        SchedulerMCP["@yoda/scheduler-mcp<br/>CreateSchedule, GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail, SendSMS"]
    end
    
    %% Flow connections
    YodaUI -->|"{ prompt, sessionId }"| API
    ListAgents --> AuthTool
    AuthTool -->|"role_categories: ['csr']"| ListAgents
    ListAgents -->|"filtered agents by role"| Workflow
    Goals -->|"agents with tailored behaviors"| ListAgents
    SameTools --> BackendInfra
    
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef yoda fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef auth fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef goals fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef backend fill:#e8eaf6,stroke:#3f51b5,stroke-width:2px
    
    class Frontend frontend
    class YODA yoda
    class AuthMCP auth
    class Goals goals
    class BackendInfra backend
```

**Benefits of Role-Based Category Approach:**

- **üé≠ Role-Specific Agent Behaviors:** Same tools with tailored conversation styles for different user types
- **üè¢ Enterprise JWT Abstraction:** @entity/auth-mcp handles complex enterprise authentication mapping
- **üîç Scope-Aware Discovery:** Users only see agents appropriate for their role
- **üß© Backend Tool Freedom:** Tool teams can freely use all infrastructure MCP tools
- **‚ö° Enhanced ListAgents:** Single tool modification provides complete role-based filtering

**Example Flow:**

**1. Enterprise JWT ‚Üí Role Categories:**
```json
// @entity/auth-mcp receives complex enterprise JWT
{
  "session_id": "sess_abc123"
}

// Complex enterprise JWT from company auth system
{
  "user_id": "emp_456",
  "roles": ["customer_service", "support_tier_2"], 
  "department": "customer_success",
  "permissions": ["view_customer_data", "modify_orders"],
  "groups": ["west_coast_team", "senior_agents"]
}

// @entity/auth-mcp maps to clean role categories
{
  "user_id": "emp_456",
  "role_categories": ["csr"],  // Clean, simple role mapping
  "session_expires": "2024-01-15T10:30:00Z"
}
```

**2. Scope-Aware Agent Discovery:**
```json
// Enhanced listAgents with role filtering
{
  "session_id": "sess_abc123",
  "user_role_categories": ["csr"]
}

// Response: Only agents appropriate for CSR role
{
  "agents": [
    {
      "agent_name": "Customer Support Assistant",
      "goal_id": "goal_csr_order_status", 
      "agent_description": "Professional order status checking with technical details",
      "conversation_style": "direct_professional"
    },
    {
      "agent_name": "Account Management Helper", 
      "goal_id": "goal_csr_account_mgmt",
      "agent_description": "Manage customer accounts with administrative tools",
      "conversation_style": "business_focused"
    }
  ]
}
```

**3. Role-Specific Agent Behavior:**
```python
# csr.py - Professional, direct style
goal_csr_order_status = AgentGoal(
    category_tag="csr",
    example_conversation_history="\n ".join([
        "user: Order status for 102",
        "agent: Order ID: 102. Status: Shipped. Tracking: 039813852990618. ETA: April 30, 2025.",
        "user: Any delivery issues?", 
        "agent: No delivery exceptions. Package in transit. Last scan: Phoenix, AZ."
    ])
)

# client.py - Friendly, conversational style  
goal_client_order_status = AgentGoal(
    category_tag="client",
    example_conversation_history="\n ".join([
        "user: Hi, how's my order doing?",
        "agent: Hi there! I'd be happy to check on your order. What's your order number?",
        "user: 102",
        "agent: Great news! Your order shipped and is on its way! üòä It should arrive by April 30th."
    ])
)
```



---

## **Alerts & Scheduling Backend Tools**

The alerts and scheduling system exemplifies YODA's backend infrastructure pattern: specialized MCP servers that provide persistent, user-scoped capabilities to any goal-oriented tool. These backend tools manage stateful operations independently while remaining composable across all business domains.

### **Alert Backend Architecture**

**@yoda/alerts-mcp-server** provides persistent user alert capabilities:

```python
# Goal-oriented tools can create sophisticated alerts
await alerts_mcp.create_user_alert(
    user_id="user_456",
    condition="BTC price drops below $50,000 AND portfolio loss > 5%",
    alert_type="financial_risk",
    priority="high"
)

# Backend manages persistent storage and monitoring
{
  "alert_id": "alert_123",
  "user_id": "user_456", 
  "condition": "BTC < $50000 AND portfolio_loss > 0.05",
  "status": "active",
  "created_at": "2024-01-10T09:00:00Z",
  "triggered_at": null
}
```

### **Scheduling Backend Architecture**

**@yoda/scheduler-mcp-server** handles time-based and conditional automation:

```python
# Any business tool can schedule actions
await scheduler_mcp.create_schedule(
    user_id="user_456",
    action="transfer_to_savings",
    condition="monthly",
    action_params={"amount": 500, "target_account": "savings_001"}
)

# Backend manages execution timing and state
{
  "schedule_id": "schedule_789",
  "user_id": "user_456",
  "action": "transfer_to_savings", 
  "condition": "monthly",
  "status": "pending",
  "next_execution": "2024-02-01T00:00:00Z",
  "action_params": {"amount": 500, "target_account": "savings_001"}
}
```

### **Cross-Domain Integration Example**

```python
# HR tool creating finance-related schedule
class HRMCP:
    async def setup_payroll_automation(self, employee_id, salary_amount):
        # Create recurring payroll schedule using backend tool
        await self.scheduler.create_schedule(
            user_id=employee_id,
            action="process_payroll",
            condition="bi_weekly", 
            action_params={
                "amount": salary_amount,
                "employee_id": employee_id,
                "account": "payroll_account"
            }
        )
        
        # Create alert for payroll failures using backend tool
        await self.alerts.create_user_alert(
            user_id=employee_id,
            condition="payroll_failed OR insufficient_funds",
            alert_type="payroll_issue",
            priority="critical"
        )
```


