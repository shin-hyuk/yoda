# YODA Documentation

                                ‚†Ä‚¢Ä‚£†‚£Ñ‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£¥‚£∂‚°æ‚†ø‚†ø‚†ø‚†ø‚¢∑‚£∂‚£¶‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚¢∞‚£ø‚°ü‚†õ‚†õ‚†õ‚†ª‚†ø‚†ø‚¢ø‚£∂‚£∂‚£¶‚£§‚£§‚£Ä‚£Ä‚°Ä‚£Ä‚£¥‚£æ‚°ø‚†ü‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†ª‚¢ø‚£∑‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä
                                ‚†Ä‚†ª‚£ø‚£¶‚°Ä‚†Ä‚†â‚†ì‚†∂‚¢¶‚£Ñ‚£Ä‚†â‚†â‚†õ‚†õ‚†ª‚†ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚£§‚°Ä‚†Ä‚†Ä‚¢†‚†Ä‚†Ä‚†Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†õ‚¢ª‚£ø
                                ‚†Ä‚†Ä‚†à‚†ª‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢∑‚£∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†ô‚¢∑‚°Ä‚†∏‚°á‚†Ä‚£∞‚†á‚†Ä‚¢Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£§‚£§‚£∂‚°∂‚†∂‚†∂‚†í‚†Ç‚†Ä‚†Ä‚£†‚£æ‚†ü
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚°Ñ‚£†‚£¥‚£ø‚£Ø‚£≠‚£Ω‚£∑‚£Ü‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£ø‚£¶‚°Ä‚†Ä‚£†‚£æ‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ü‚†Å‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ó‚¢ª‚£ø‚£ß‚£Ω‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚£Ä‚£Ä‚†Ä‚¢†‚£ø‚£ß‚£º‚£ø‚£ø‚£ø‚£ø‚†ó‚†∞‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£∂‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚†É‚†à‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†æ‚£•‚°¨‚†ó‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†Ä‚¢Ä‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†ø‚£∑‚£∂‚£§‚£§‚£Ñ‚£∞‚£Ñ‚†Ä‚†Ä‚†â‚†â‚†â‚†Å‚†Ä‚¢Ä‚£Ä‚£†‚£Ñ‚£Ä‚°Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£•‚£§‚£§‚£§‚£∂‚£∂‚°ø‚†ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢ª‚£ø‚†õ‚¢ø‚£∑‚£¶‚£§‚£¥‚£∂‚£∂‚£¶‚£§‚£§‚£§‚£§‚£¨‚£•‚°¥‚†∂‚†æ‚†ø‚†ø‚†ø‚†ø‚†õ‚¢õ‚£ø‚£ø‚£ø‚£Ø‚°â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ß‚°Ä‚†à‚†â‚†Ä‚†à‚†Å‚£æ‚†õ‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£ø‚†ü‚†â‚£π‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£∏‚£ø‚£ø‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£∂‚£ø‚†ã‚£ø‚†õ‚†É‚†Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚¢ø‚°Ä‚†à‚¢π‚°ø‚†∂‚£∂‚£º‚°á‚†Ä‚¢Ä‚£Ä‚£Ä‚£§‚£¥‚£æ‚†ü‚†ã‚£°‚£ø‚°ü‚†Ä‚¢ª‚£∂‚†∂‚£ø‚£ø‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£∑‚°à‚¢ø‚£¶‚£∏‚†á‚¢Ä‚°ø‚†ø‚†ø‚°ø‚†ø‚†ø‚£ø‚†õ‚†ã‚†Å‚†Ä‚£¥‚†ü‚£ø‚£ß‚°Ä‚†à‚¢Å‚£∞‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚¢ª‚£¶‚£à‚£Ω‚£Ä‚£æ‚†É‚†Ä‚¢∏‚°á‚†Ä‚¢∏‚°á‚†Ä‚¢Ä‚£†‚°æ‚†ã‚¢∞‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†ø‚¢ø‚£ø‚£ø‚°ü‚†õ‚†É‚†Ä‚†Ä‚£æ‚†Ä‚†Ä‚¢∏‚°á‚†ê‚†ø‚†ã‚†Ä‚†Ä‚£ø‚¢ª‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Å‚¢Ä‚°¥‚†ã‚†Ä‚£ø‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£Å‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†õ‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

## Overview

YODA is a Temporal-powered AI agent system for integrating external business tools via Model Context Protocol (MCP) servers. This document covers LLM-driven agent orchestration, team workflows, JWT authentication, MCP integration, and persistent alert/schedule systems.

### Architectural Traits

- **[MCP Servers for Tools](#mcp-servers-for-tools):** Modular tools, auto-discovered via NPM
- **[Parallel Team Workflow](#parallel-team-workflow):** Tool and goal teams work in parallel with minimal coordination
- **[Goal Switching Architecture](#goal-switching-architecture):** Users can seamlessly switch between agent personas and goals
- **[MCP Tool Documentation Standards](#mcp-tool-documentation-standards):** Standardized documentation for tool response schemas and examples alongside standard MCP protocol
- **[JWT-Based Authorization Flow](#jwt-based-authorization-flow):** User access is securely managed with JWT tokens across all tools
- **[Persistent Alerts & Schedules](#persistent-alerts--schedules):** User-specific alerts and schedules are managed as stateful JSON feeds within the orchestrator

**Note:** All file paths and package names mentioned in this document are exact locations used in the codebase. Tool and goal teams only need to update these specific files and packages to register new tools, define agent goals, or integrate new business logic as described below. Note that "goal" and "agent" are used interchangeably throughout this document.

---

## MCP Servers for Tools

YODA's architecture is modular by design: YODA itself acts as the orchestrator ("the brain"), while all business logic and integrations are provided by independently developed MCP servers ("the hands"). MCP servers expose tools without needing to know anything about the orchestrator's internals, enabling infinite scalability and rapid, parallel development.

### Tool Registration & Deployment

1. Publish MCP server to NPM
2. Register server endpoint in the orchestrator
3. Reference server in goal files
4. Tools are auto-discovered at runtime

**Note:** For the exact file paths, code references, and detailed step-by-step process, see the [Parallel Team Workflow](#parallel-team-workflow) section.

```mermaid
graph TB
    User["<b>User Input</b>"] --> Frontend["<b>React Frontend</b><br/><i>localhost:5173</i>"]
    Frontend --> API["<b>FastAPI Server</b><br/><i>localhost:8000</i>"]
    API --> Temporal["<b>Temporal Server</b><br/><i>localhost:7233</i>"]
    
    subgraph YodaBrain ["üß† <b>YODA - The Orchestrator Brain</b>"]
        Temporal --> Worker["<b>Temporal Worker</b>"]
        Worker --> AgentWorkflow["<b>AgentGoalWorkflow</b><br/><i>workflows/agent_goal_workflow.py</i>"]
        AgentWorkflow --> LLMActivity["<b>LLM Activities</b><br/><i>activities/tool_activities.py</i>"]
        AgentWorkflow --> MCPClientManager["<b>MCP Client Manager</b><br/><i>shared/mcp_client_manager.py</i>"]
        MCPClientManager --> RuntimeDiscovery["<b>Runtime Tool Discovery</b><br/><i>mcp_list_tools activity</i>"]
    end
    
    subgraph ExternalMCP ["üåê <b>External MCP Ecosystem</b>"]
        BusinessAPI["<b>Business API</b><br/><i>npx @company/business-mcp</i>"]
        AnalyticsService["<b>Analytics Service</b><br/><i>npx @company/analytics-mcp</i>"]
        IntegrationHub["<b>Integration Hub</b><br/><i>npx @company/integration-mcp</i>"]
    end
    
    subgraph Infrastructure ["üèóÔ∏è <b>Infrastructure</b>"]
        Postgres[("<b>PostgreSQL</b><br/><i>Temporal Persistence</i>")]
        NPMRegistry[("<b>NPM Registry</b><br/><i>MCP Package Distribution</i>")]
    end
    
    %% Connections
    MCPClientManager --> BusinessAPI
    MCPClientManager --> AnalyticsService  
    MCPClientManager --> IntegrationHub
    BusinessAPI -.->|Discovery| RuntimeDiscovery
    AnalyticsService -.->|Discovery| RuntimeDiscovery
    IntegrationHub -.->|Discovery| RuntimeDiscovery
    Temporal --> Postgres
    ExternalMCP --> NPMRegistry
    
    classDef brain fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef infra fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YodaBrain brain
    class ExternalMCP external
    class Infrastructure infra
```

## **MCP Tool Documentation Standards**

YODA's scalable tool ecosystem is built on close collaboration between two teams: **tool teams**, who develop and maintain MCP servers, and **goal teams**, who design agent experiences that leverage those tools. The standard MCP protocol exposes only a tool's name, description, and input schema‚Äîleaving goal teams to infer or reverse-engineer response formats.

To solve this, YODA establishes a shared documentation standard: both teams collaborate on a living document that clearly defines response schemas and example payloads. This document acts first as a requirements spec from the goal team, then as the authoritative reference from the tool team, ensuring agent design is accurate and tool integration is seamless.

**Example: Documentation Standard in Practice**

```markdown
# @company/customer-mcp-server Documentation

## GetCustomerDetails Tool

**Summary:**
Retrieves detailed customer information from the CRM system. Returns customer profile data including contact information, account status, and registration details.

**Input Schema:**
{
    "type": "object",
    "properties": {
    "customer_id": {"type": "string", "description": "Unique customer identifier"}
    },
    "required": ["customer_id"]
  }

**Response Schema:**
{
  "type": "object", 
  "properties": {
    "customer_id": {"type": "string"},
    "name": {"type": "string"},
    "email": {"type": "string"},
    "status": {"type": "string"},
    "created_date": {"type": "string", "format": "date"}
  },
  "required": ["customer_id", "name", "email", "status"]
}

**Examples:**
- Success: {"customer_id": "CUST_123", "name": "John Smith", "email": "john@example.com", "status": "active", "created_date": "2024-01-15"}
- Not Found: {"error": "Customer not found", "customer_id": "CUST_999"}
```

---

## Streamlined Team Workflow

1. **Goal Team: Define & Send Requirement**  
   Prepare a structured MCP server/tool requirement document (as shown in the documentation standards above).

2. **Tool Team: Develop & Document**  
   Implement the MCP server and tools based on the requirement, update shared documentation with finalized response schemas and examples, then publish to NPM.

3. **Goal Team: Integrate & Design**  
   Add the server definition to the orchestrator, reference it in goal files, and use the documentation to write accurate `example_conversation_history` for agent behavior.

```python
# Goal team uses finalized documentation to write accurate tool responses:
example_conversation_history="\n ".join([
    "user_confirmed_tool_run: <user clicks confirm on GetCustomerDetails tool>",
    "tool_result: { 'customer_id': 'CUST_123', 'name': 'John Smith', 'email': 'john@example.com', 'status': 'active' }",  # From tool docs
    "agent: Found customer John Smith (john@example.com) - account is active."
])
```

---

## **Goal Switching Architecture**

Original Temporal supports both single-agent and multi-agent modes, but YODA defaults to multi-goal mode‚Äîenabling agent orchestration and fully realizing the MCP framework.

```mermaid
graph TD
    subgraph AnyGoal ["Any Active Goal (Travel, HR, Finance, etc.)"]
        direction TB
        UserInGoal[User in Middle of Goal<br/>e.g., Booking Flights]
        GoalTools[Goal-Specific Tools<br/>+ ListAgents tool<br/>auto-added in multi-goal mode]
        
        UserInGoal --> GoalTools
    end
    
    subgraph TwoEscapeRoutes ["Two Escape Routes from Any Goal"]
        direction TB
        
        subgraph Route1 ["Route 1: Natural Completion"]
            direction TB
            CompleteAllSteps[Complete ALL Goal Steps<br/>e.g., Search ‚Üí Book ‚Üí Invoice]
            SystemTrigger[System Triggers<br/>'pick-new-goal']
            AutoReturn[Auto-Return to<br/>goal_choose_agent_type]
            
            CompleteAllSteps --> SystemTrigger
            SystemTrigger --> AutoReturn
        end
        
        subgraph Route2 ["Route 2: Instant Switch"]
            direction TB
            UserCallsListAgents[User Calls ListAgents<br/>from any goal]
            InstantJump[Instant Jump to<br/>goal_choose_agent_type]
            ChangeGoalAvailable[ChangeGoal Tool<br/>Now Available]
            
            UserCallsListAgents --> InstantJump
            InstantJump --> ChangeGoalAvailable
        end
    end
    
    subgraph AgentSelection ["Agent Selection Hub (goal_choose_agent_type)"]
        direction TB
        ListAgentsSilent[ListAgents Runs Silently<br/>Shows All Available Agents]
        ChangeGoalTool[ChangeGoal Tool Available<br/>Can Switch to ANY Goal]
        NewGoalSelected[User Selects New Goal<br/>e.g., HR, Finance, Travel]
        
        ListAgentsSilent --> ChangeGoalTool
        ChangeGoalTool --> NewGoalSelected
    end
    
    %% Connections
    GoalTools -->|Route 1| Route1
    GoalTools -->|Route 2| Route2
    AutoReturn --> AgentSelection
    ChangeGoalAvailable --> AgentSelection
    NewGoalSelected --> AnyGoal
    
    classDef anyGoal fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef route1 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef route2 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef agentHub fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class AnyGoal anyGoal
    class Route1 route1
    class Route2 route2
    class AgentSelection agentHub
```



---

## **Backend Infrastructure Tools**

YODA's architecture separates **goal-oriented tools** (business logic for user interactions) from **backend infrastructure tools**. Backend infrastructure tools are divided into two distinct types: **orchestrator-level tools** that handle platform-specific authentication and user scoping across different deployment contexts (portal, app, enterprise), and **goal-oriented backend tools** that provide universal functionality like alerts, scheduling, and notifications that any business tool can consume regardless of platform.

### **Architecture Pattern: Two-Tier Backend Infrastructure**

```mermaid
graph TD
    subgraph YODA ["üß† YODA Orchestrator"]
        ListAgents["Enhanced ListAgents<br/>scope-aware filtering"]
        Workflow["AgentGoalWorkflow<br/>user scope management"]
    end
    
    subgraph OrchBackend ["üîê Orchestrator-Level Backend Tools"]
        PortalAuth["@portal/auth-mcp<br/>Portal JWT ‚Üí roles"]
        AppAuth["@app/auth-mcp<br/>App JWT ‚Üí roles"] 
        EnterpriseAuth["@enterprise/auth-mcp<br/>SSO JWT ‚Üí roles"]
    end
    
    subgraph GoalBackend ["üîß Goal-Oriented Backend Tools"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert<br/>GetUserAlerts"]
        ScheduleMCP["@yoda/scheduler-mcp<br/>CreateSchedule<br/>GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail<br/>SendSMS"]
        AnalyticsMCP["@yoda/analytics-mcp<br/>TrackEvent<br/>GetMetrics"]
    end
    
    subgraph BusinessTools ["üè¢ Goal-Oriented Tools"]
        CustomerMCP["@company/customer-mcp<br/>GetCustomerDetails<br/>UpdateCustomer"]
        FinanceMCP["@company/finance-mcp<br/>TransferMoney<br/>GetBalance"]
        HRMCP["@company/hr-mcp<br/>BookPTO<br/>GetPayroll"]
    end
    
    %% Orchestrator uses platform-specific auth
    YODA --> PortalAuth
    YODA --> AppAuth  
    YODA --> EnterpriseAuth
    
    %% Business tools use goal-oriented backend tools
    CustomerMCP --> AlertsMCP
    CustomerMCP --> NotificationMCP
    FinanceMCP --> AlertsMCP
    FinanceMCP --> ScheduleMCP
    HRMCP --> ScheduleMCP
    HRMCP --> AnalyticsMCP
    
    classDef orch fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef orchBackend fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef goalBackend fill:#e8eaf6,stroke:#3f51b5,stroke-width:2px
    classDef business fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YODA orch
    class OrchBackend orchBackend
    class GoalBackend goalBackend
    class BusinessTools business
```



### **Orchestrator-Level Backend Tools**

Platform-specific authentication servers that YODA Orchestrator uses to handle JWT complexity and map to standardized role categories:

```python
# Different auth servers for different deployment platforms
class YODAOrchestrator:
    async def authenticate_user(self, session_id, platform):
        if platform == "portal":
            auth_result = await portal_auth_mcp.authenticate_user(session_id)
        elif platform == "mobile_app":
            auth_result = await app_auth_mcp.authenticate_user(session_id) 
        elif platform == "enterprise":
            auth_result = await enterprise_auth_mcp.authenticate_user(session_id)
        
        # All return standardized format: {"user_id": "...", "role_categories": ["csr"]}
        return auth_result

# @portal/auth-mcp handles portal-specific JWT
async def authenticate_user(session_id):
    portal_jwt = await portal_system.validate_session(session_id)
    # Complex portal JWT ‚Üí clean roles
    role_categories = map_portal_roles(portal_jwt["user_type"], portal_jwt["permissions"])
    return {"user_id": portal_jwt["user_id"], "role_categories": role_categories}

# @enterprise/auth-mcp handles enterprise SSO  
async def authenticate_user(session_id):
    sso_jwt = await enterprise_sso.validate_session(session_id)
    # Complex enterprise JWT ‚Üí clean roles
    role_categories = map_enterprise_roles(sso_jwt["roles"], sso_jwt["department"])
    return {"user_id": sso_jwt["employee_id"], "role_categories": role_categories}
```

### **Goal-Oriented Backend Tools**

Universal infrastructure tools that any business MCP server can use for common functionality:

```python
# @company/finance-mcp-server using goal-oriented backend tools
class FinanceMCP:
    def __init__(self):
        # Goal-oriented backend tools - available to any business tool
        self.alerts = MCPClient("@yoda/alerts-mcp")
        self.scheduler = MCPClient("@yoda/scheduler-mcp") 
        self.notifications = MCPClient("@yoda/notification-mcp")
        self.analytics = MCPClient("@yoda/analytics-mcp")
    
    async def transfer_money(self, from_account, to_account, amount, user_id):
        # Business logic
        transfer = await self.execute_transfer(from_account, to_account, amount)
        
        # Use goal-oriented backend infrastructure
        if amount > 10000:
            await self.alerts.create_user_alert(
                user_id=user_id,
                condition=f"Large transfer of ${amount:,.2f} completed",
                alert_type="high_value_transaction"
            )
        
        await self.notifications.send_email(
            user_id=user_id,
            template="transfer_confirmation", 
            data={"amount": amount, "to_account": to_account}
        )
        
        await self.analytics.track_event(
            user_id=user_id,
            event="money_transfer",
            metadata={"amount": amount, "type": "internal"}
        )
        
        return {"transfer_id": transfer.id, "status": "completed"}
```

---

## **User Management & Authentication Flow**

YODA implements scope-based agent categories where each user role (client, csr, ops, sales) has dedicated agent goals with tailored behaviors and conversation styles. The system uses a single authentication MCP server to handle JWT complexity and map enterprise authentication to clean role categories, with the `listAgents` tool providing scope-aware agent discovery.

```mermaid
graph TD
    subgraph Frontend ["üåê Frontend (Embedded in Portal)"]
        PortalSession["Portal Session<br/>sessionId: abc123"]
        YodaUI["YODA Chat UI<br/>React Component"]
        PortalSession --> YodaUI
    end
    
    subgraph YODA ["üß† YODA Orchestrator"]
        API["FastAPI<br/>/send-prompt + sessionId"]
        Workflow["AgentGoalWorkflow<br/>role-aware processing"]
        ListAgents["Enhanced ListAgents Tool<br/>scope-aware filtering"]
        
        API --> Workflow
        Workflow --> ListAgents
    end
    
    subgraph AuthMCP ["üîê @entity/auth-mcp-server"]
        AuthTool["AuthenticateUser<br/>sessionId ‚Üí role_categories"]
        JWTMapping["JWT Complexity Handler<br/>enterprise JWT ‚Üí clean roles"]
        
        AuthTool --> JWTMapping
    end
    
    subgraph Goals ["üìÅ Role-Based Goal Categories"]
        ClientGoals["client.py<br/>Friendly conversation style"]
        CSRGoals["csr.py<br/>Professional support style"] 
        OpsGoals["ops.py<br/>Direct technical reports"]
        SalesGoals["sales.py<br/>Relationship-focused style"]
        
        ClientGoals --> SameTools["Same Business Tools<br/>Different Agent Behaviors"]
        CSRGoals --> SameTools
        OpsGoals --> SameTools
        SalesGoals --> SameTools
    end
    
    subgraph BackendInfra ["üîß Backend Infrastructure Tools"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert, GetAlerts"]
        SchedulerMCP["@yoda/scheduler-mcp<br/>CreateSchedule, GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail, SendSMS"]
    end
    
    %% Flow connections
    YodaUI -->|"{ prompt, sessionId }"| API
    ListAgents --> AuthTool
    AuthTool -->|"role_categories: ['csr']"| ListAgents
    ListAgents -->|"filtered agents by role"| Workflow
    Goals -->|"agents with tailored behaviors"| ListAgents
    SameTools --> BackendInfra
    
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef yoda fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef auth fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef goals fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef backend fill:#e8eaf6,stroke:#3f51b5,stroke-width:2px
    
    class Frontend frontend
    class YODA yoda
    class AuthMCP auth
    class Goals goals
    class BackendInfra backend
```

**Benefits of Role-Based Category Approach:**

- **üé≠ Role-Specific Agent Behaviors:** Same tools with tailored conversation styles for different user types
- **üè¢ Enterprise JWT Abstraction:** @entity/auth-mcp handles complex enterprise authentication mapping
- **üîç Scope-Aware Discovery:** Users only see agents appropriate for their role
- **üß© Backend Tool Freedom:** Tool teams can freely use all infrastructure MCP tools
- **‚ö° Enhanced ListAgents:** Single tool modification provides complete role-based filtering

**Example Flow:**

**1. Enterprise JWT ‚Üí Role Categories:**
```json
// @entity/auth-mcp receives complex enterprise JWT
{
  "session_id": "sess_abc123"
}

// Complex enterprise JWT from company auth system
{
  "user_id": "emp_456",
  "roles": ["customer_service", "support_tier_2"], 
  "department": "customer_success",
  "permissions": ["view_customer_data", "modify_orders"],
  "groups": ["west_coast_team", "senior_agents"]
}

// @entity/auth-mcp maps to clean role categories
{
  "user_id": "emp_456",
  "role_categories": ["csr"],  // Clean, simple role mapping
  "session_expires": "2024-01-15T10:30:00Z"
}
```

**2. Scope-Aware Agent Discovery:**
```json
// Enhanced listAgents with role filtering
{
  "session_id": "sess_abc123",
  "user_role_categories": ["csr"]
}

// Response: Only agents appropriate for CSR role
{
  "agents": [
    {
      "agent_name": "Customer Support Assistant",
      "goal_id": "goal_csr_order_status", 
      "agent_description": "Professional order status checking with technical details",
      "conversation_style": "direct_professional"
    },
    {
      "agent_name": "Account Management Helper", 
      "goal_id": "goal_csr_account_mgmt",
      "agent_description": "Manage customer accounts with administrative tools",
      "conversation_style": "business_focused"
    }
  ]
}
```

**3. Role-Specific Agent Behavior:**
```python
# csr.py - Professional, direct style
goal_csr_order_status = AgentGoal(
    category_tag="csr",
    example_conversation_history="\n ".join([
        "user: Order status for 102",
        "agent: Order ID: 102. Status: Shipped. Tracking: 039813852990618. ETA: April 30, 2025.",
        "user: Any delivery issues?", 
        "agent: No delivery exceptions. Package in transit. Last scan: Phoenix, AZ."
    ])
)

# client.py - Friendly, conversational style  
goal_client_order_status = AgentGoal(
    category_tag="client",
    example_conversation_history="\n ".join([
        "user: Hi, how's my order doing?",
        "agent: Hi there! I'd be happy to check on your order. What's your order number?",
        "user: 102",
        "agent: Great news! Your order shipped and is on its way! üòä It should arrive by April 30th."
    ])
)
```



---

## **Goal-Oriented Backend Tools in Action**

Goal-oriented backend tools provide universal infrastructure capabilities that any business MCP server can use. These tools manage persistent, stateful operations while remaining platform-agnostic and composable across all business domains.

### **@yoda/alerts-mcp-server**

Universal alerting infrastructure that any business tool can use for user notifications:

```python
# Any business tool can create sophisticated alerts
await alerts_mcp.create_user_alert(
    user_id="user_456",
    condition="BTC price drops below $50,000 AND portfolio loss > 5%",
    alert_type="financial_risk",
    priority="high"
)

# Universal alert format across all business domains
{
  "alert_id": "alert_123",
  "user_id": "user_456", 
  "condition": "BTC < $50000 AND portfolio_loss > 0.05",
  "status": "active",
  "created_at": "2024-01-10T09:00:00Z",
  "triggered_at": null
}
```

### **@yoda/scheduler-mcp-server**

Universal scheduling infrastructure for time-based and conditional automation:

```python
# Any business tool can schedule actions
await scheduler_mcp.create_schedule(
    user_id="user_456",
    action="transfer_to_savings",
    condition="monthly",
    action_params={"amount": 500, "target_account": "savings_001"}
)

# Universal schedule format across all business domains
{
  "schedule_id": "schedule_789",
  "user_id": "user_456",
  "action": "transfer_to_savings", 
  "condition": "monthly",
  "status": "pending",
  "next_execution": "2024-02-01T00:00:00Z",
  "action_params": {"amount": 500, "target_account": "savings_001"}
}
```

### **@yoda/notification-mcp-server**

Universal notification infrastructure for multi-channel communications:

```python
# Any business tool can send notifications
await notification_mcp.send_email(
    user_id="user_456",
    template="payment_confirmation",
    data={"amount": "$1,500", "account": "checking"}
)

await notification_mcp.send_sms(
    user_id="user_456", 
    message="Your payment of $1,500 has been processed successfully."
)

await notification_mcp.send_push_notification(
    user_id="user_456",
    title="Payment Complete",
    body="Your transfer is complete. Check your account for details."
)
```

### **@yoda/analytics-mcp-server**

Universal analytics infrastructure for business intelligence and monitoring:

```python
# Any business tool can track events and metrics
await analytics_mcp.track_event(
    user_id="user_456",
    event="money_transfer",
    metadata={
        "amount": 1500,
        "type": "internal",
        "from_account": "checking",
        "to_account": "savings"
    }
)

await analytics_mcp.track_metric(
    metric_name="daily_transaction_volume",
    value=1500,
    tags={"user_type": "premium", "region": "west_coast"}
)
```

### **Cross-Domain Integration Example**

Business tools from different domains using the same goal-oriented backend infrastructure:

```python
# HR tool using multiple goal-oriented backend tools
class HRMCP:
    def __init__(self):
        self.scheduler = MCPClient("@yoda/scheduler-mcp")
        self.alerts = MCPClient("@yoda/alerts-mcp")
        self.notifications = MCPClient("@yoda/notification-mcp")
        self.analytics = MCPClient("@yoda/analytics-mcp")
    
    async def setup_payroll_automation(self, employee_id, salary_amount):
        # Schedule recurring payroll using universal scheduler
        await self.scheduler.create_schedule(
            user_id=employee_id,
            action="process_payroll",
            condition="bi_weekly",
            action_params={"amount": salary_amount, "employee_id": employee_id}
        )
        
        # Create alert for payroll failures using universal alerts
        await self.alerts.create_user_alert(
            user_id=employee_id,
            condition="payroll_failed OR insufficient_funds",
            alert_type="payroll_issue",
            priority="critical"
        )
        
        # Send confirmation using universal notifications
        await self.notifications.send_email(
            user_id=employee_id,
            template="payroll_setup_confirmation",
            data={"amount": salary_amount, "frequency": "bi_weekly"}
        )
        
        # Track setup event using universal analytics
        await self.analytics.track_event(
            user_id=employee_id,
            event="payroll_automation_setup",
            metadata={"salary_amount": salary_amount}
        )
```


