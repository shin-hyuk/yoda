# YODA Documentation

                                ‚†Ä‚¢Ä‚£†‚£Ñ‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£¥‚£∂‚°æ‚†ø‚†ø‚†ø‚†ø‚¢∑‚£∂‚£¶‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚¢∞‚£ø‚°ü‚†õ‚†õ‚†õ‚†ª‚†ø‚†ø‚¢ø‚£∂‚£∂‚£¶‚£§‚£§‚£Ä‚£Ä‚°Ä‚£Ä‚£¥‚£æ‚°ø‚†ü‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†ª‚¢ø‚£∑‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä
                                ‚†Ä‚†ª‚£ø‚£¶‚°Ä‚†Ä‚†â‚†ì‚†∂‚¢¶‚£Ñ‚£Ä‚†â‚†â‚†õ‚†õ‚†ª‚†ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚£§‚°Ä‚†Ä‚†Ä‚¢†‚†Ä‚†Ä‚†Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†õ‚¢ª‚£ø
                                ‚†Ä‚†Ä‚†à‚†ª‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢∑‚£∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†ô‚¢∑‚°Ä‚†∏‚°á‚†Ä‚£∞‚†á‚†Ä‚¢Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£§‚£§‚£∂‚°∂‚†∂‚†∂‚†í‚†Ç‚†Ä‚†Ä‚£†‚£æ‚†ü
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚°Ñ‚£†‚£¥‚£ø‚£Ø‚£≠‚£Ω‚£∑‚£Ü‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£ø‚£¶‚°Ä‚†Ä‚£†‚£æ‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ü‚†Å‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ó‚¢ª‚£ø‚£ß‚£Ω‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚£Ä‚£Ä‚†Ä‚¢†‚£ø‚£ß‚£º‚£ø‚£ø‚£ø‚£ø‚†ó‚†∞‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£∂‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚†É‚†à‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†æ‚£•‚°¨‚†ó‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†Ä‚¢Ä‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†ø‚£∑‚£∂‚£§‚£§‚£Ñ‚£∞‚£Ñ‚†Ä‚†Ä‚†â‚†â‚†â‚†Å‚†Ä‚¢Ä‚£Ä‚£†‚£Ñ‚£Ä‚°Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£•‚£§‚£§‚£§‚£∂‚£∂‚°ø‚†ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢ª‚£ø‚†õ‚¢ø‚£∑‚£¶‚£§‚£¥‚£∂‚£∂‚£¶‚£§‚£§‚£§‚£§‚£¨‚£•‚°¥‚†∂‚†æ‚†ø‚†ø‚†ø‚†ø‚†õ‚¢õ‚£ø‚£ø‚£ø‚£Ø‚°â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ß‚°Ä‚†à‚†â‚†Ä‚†à‚†Å‚£æ‚†õ‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£ø‚†ü‚†â‚£π‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£∏‚£ø‚£ø‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£∂‚£ø‚†ã‚£ø‚†õ‚†É‚†Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚¢ø‚°Ä‚†à‚¢π‚°ø‚†∂‚£∂‚£º‚°á‚†Ä‚¢Ä‚£Ä‚£Ä‚£§‚£¥‚£æ‚†ü‚†ã‚£°‚£ø‚°ü‚†Ä‚¢ª‚£∂‚†∂‚£ø‚£ø‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£∑‚°à‚¢ø‚£¶‚£∏‚†á‚¢Ä‚°ø‚†ø‚†ø‚°ø‚†ø‚†ø‚£ø‚†õ‚†ã‚†Å‚†Ä‚£¥‚†ü‚£ø‚£ß‚°Ä‚†à‚¢Å‚£∞‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚¢ª‚£¶‚£à‚£Ω‚£Ä‚£æ‚†É‚†Ä‚¢∏‚°á‚†Ä‚¢∏‚°á‚†Ä‚¢Ä‚£†‚°æ‚†ã‚¢∞‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†ø‚¢ø‚£ø‚£ø‚°ü‚†õ‚†É‚†Ä‚†Ä‚£æ‚†Ä‚†Ä‚¢∏‚°á‚†ê‚†ø‚†ã‚†Ä‚†Ä‚£ø‚¢ª‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Å‚¢Ä‚°¥‚†ã‚†Ä‚£ø‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£Å‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†õ‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

## Overview

YODA is a Temporal-powered AI agent system for integrating external business tools via Model Context Protocol (MCP) servers. This document covers LLM-driven agent orchestration, team workflows, JWT authentication, MCP integration, and persistent alert/schedule systems.

### Architectural Traits

- **[MCP Servers for Tools](#mcp-servers-for-tools):** Modular tools, auto-discovered via NPM
- **[Parallel Team Workflow](#parallel-team-workflow):** Tool and goal teams work in parallel with minimal coordination
- **[Goal Switching Architecture](#goal-switching-architecture):** Users can seamlessly switch between agent personas and goals
- **[MCP Tool Documentation Standards](#mcp-tool-documentation-standards):** Standardized documentation for tool response schemas and examples alongside standard MCP protocol
- **[JWT-Based Authorization Flow](#jwt-based-authorization-flow):** User access is securely managed with JWT tokens across all tools
- **[Persistent Alerts & Schedules](#persistent-alerts--schedules):** User-specific alerts and schedules are managed as stateful JSON feeds within the orchestrator

**Note:** All file paths and package names mentioned in this document are exact locations used in the codebase. Tool and goal teams only need to update these specific files and packages to register new tools, define agent goals, or integrate new business logic as described below. Note that "goal" and "agent" are used interchangeably throughout this document.

---

## MCP Servers for Tools

YODA's architecture is modular by design: YODA itself acts as the orchestrator ("the brain"), while all business logic and integrations are provided by independently developed MCP servers ("the hands"). MCP servers expose tools without needing to know anything about the orchestrator's internals, enabling infinite scalability and rapid, parallel development.

### Tool Registration & Deployment

1. Publish MCP server to NPM
2. Register server endpoint in the orchestrator
3. Reference server in goal files
4. Tools are auto-discovered at runtime

**Note:** For the exact file paths, code references, and detailed step-by-step process, see the [Parallel Team Workflow](#parallel-team-workflow) section.

```mermaid
graph TB
    User["<b>User Input</b>"] --> Frontend["<b>React Frontend</b><br/><i>localhost:5173</i>"]
    Frontend --> API["<b>FastAPI Server</b><br/><i>localhost:8000</i>"]
    API --> Temporal["<b>Temporal Server</b><br/><i>localhost:7233</i>"]
    
    subgraph YodaBrain ["üß† <b>YODA - The Orchestrator Brain</b>"]
        Temporal --> Worker["<b>Temporal Worker</b>"]
        Worker --> AgentWorkflow["<b>AgentGoalWorkflow</b><br/><i>workflows/agent_goal_workflow.py</i>"]
        AgentWorkflow --> LLMActivity["<b>LLM Activities</b><br/><i>activities/tool_activities.py</i>"]
        AgentWorkflow --> MCPClientManager["<b>MCP Client Manager</b><br/><i>shared/mcp_client_manager.py</i>"]
        MCPClientManager --> RuntimeDiscovery["<b>Runtime Tool Discovery</b><br/><i>mcp_list_tools activity</i>"]
    end
    
    subgraph ExternalMCP ["üåê <b>External MCP Ecosystem</b>"]
        BusinessAPI["<b>Business API</b><br/><i>npx @company/business-mcp</i>"]
        AnalyticsService["<b>Analytics Service</b><br/><i>npx @company/analytics-mcp</i>"]
        IntegrationHub["<b>Integration Hub</b><br/><i>npx @company/integration-mcp</i>"]
    end
    
    subgraph Infrastructure ["üèóÔ∏è <b>Infrastructure</b>"]
        Postgres[("<b>PostgreSQL</b><br/><i>Temporal Persistence</i>")]
        NPMRegistry[("<b>NPM Registry</b><br/><i>MCP Package Distribution</i>")]
    end
    
    %% Connections
    MCPClientManager --> BusinessAPI
    MCPClientManager --> AnalyticsService  
    MCPClientManager --> IntegrationHub
    BusinessAPI -.->|Discovery| RuntimeDiscovery
    AnalyticsService -.->|Discovery| RuntimeDiscovery
    IntegrationHub -.->|Discovery| RuntimeDiscovery
    Temporal --> Postgres
    ExternalMCP --> NPMRegistry
    
    classDef brain fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef infra fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YodaBrain brain
    class ExternalMCP external
    class Infrastructure infra
```

## **MCP Tool Documentation Standards**

YODA's scalable tool ecosystem is built on close collaboration between two teams: **tool teams**, who develop and maintain MCP servers, and **goal teams**, who design agent experiences that leverage those tools. The standard MCP protocol exposes only a tool's name, description, and input schema‚Äîleaving goal teams to infer or reverse-engineer response formats.

To solve this, YODA establishes a shared documentation standard: both teams collaborate on a living document that clearly defines response schemas and example payloads. This document acts first as a requirements spec from the goal team, then as the authoritative reference from the tool team, ensuring agent design is accurate and tool integration is seamless.

**Example: Documentation Standard in Practice**

```markdown
# @company/customer-mcp-server Documentation

## GetCustomerDetails Tool

**Summary:**
Retrieves detailed customer information from the CRM system. Returns customer profile data including contact information, account status, and registration details.

**Input Schema:**
{
    "type": "object",
    "properties": {
    "customer_id": {"type": "string", "description": "Unique customer identifier"}
    },
    "required": ["customer_id"]
  }

**Response Schema:**
{
  "type": "object", 
  "properties": {
    "customer_id": {"type": "string"},
    "name": {"type": "string"},
    "email": {"type": "string"},
    "status": {"type": "string"},
    "created_date": {"type": "string", "format": "date"}
  },
  "required": ["customer_id", "name", "email", "status"]
}

**Examples:**
- Success: {"customer_id": "CUST_123", "name": "John Smith", "email": "john@example.com", "status": "active", "created_date": "2024-01-15"}
- Not Found: {"error": "Customer not found", "customer_id": "CUST_999"}
```

---

## Streamlined Team Workflow

1. **Goal Team: Define & Send Requirement**  
   Prepare a structured MCP server/tool requirement document (as shown in the documentation standards above).

2. **Tool Team: Develop & Document**  
   Implement the MCP server and tools based on the requirement, update shared documentation with finalized response schemas and examples, then publish to NPM.

3. **Goal Team: Integrate & Design**  
   Add the server definition to the orchestrator, reference it in goal files, and use the documentation to write accurate `example_conversation_history` for agent behavior.

```python
# Goal team uses finalized documentation to write accurate tool responses:
example_conversation_history="\n ".join([
    "user_confirmed_tool_run: <user clicks confirm on GetCustomerDetails tool>",
    "tool_result: { 'customer_id': 'CUST_123', 'name': 'John Smith', 'email': 'john@example.com', 'status': 'active' }",  # From tool docs
    "agent: Found customer John Smith (john@example.com) - account is active."
])
```

---

## **Goal Switching Architecture**

Original Temporal supports both single-agent and multi-agent modes, but YODA defaults to multi-goal mode‚Äîenabling agent orchestration and fully realizing the MCP framework.

```mermaid
graph TD
    subgraph AnyGoal ["Any Active Goal (Travel, HR, Finance, etc.)"]
        direction TB
        UserInGoal[User in Middle of Goal<br/>e.g., Booking Flights]
        GoalTools[Goal-Specific Tools<br/>+ ListAgents tool<br/>auto-added in multi-goal mode]
        
        UserInGoal --> GoalTools
    end
    
    subgraph TwoEscapeRoutes ["Two Escape Routes from Any Goal"]
        direction TB
        
        subgraph Route1 ["Route 1: Natural Completion"]
            direction TB
            CompleteAllSteps[Complete ALL Goal Steps<br/>e.g., Search ‚Üí Book ‚Üí Invoice]
            SystemTrigger[System Triggers<br/>'pick-new-goal']
            AutoReturn[Auto-Return to<br/>goal_choose_agent_type]
            
            CompleteAllSteps --> SystemTrigger
            SystemTrigger --> AutoReturn
        end
        
        subgraph Route2 ["Route 2: Instant Switch"]
            direction TB
            UserCallsListAgents[User Calls ListAgents<br/>from any goal]
            InstantJump[Instant Jump to<br/>goal_choose_agent_type]
            ChangeGoalAvailable[ChangeGoal Tool<br/>Now Available]
            
            UserCallsListAgents --> InstantJump
            InstantJump --> ChangeGoalAvailable
        end
    end
    
    subgraph AgentSelection ["Agent Selection Hub (goal_choose_agent_type)"]
        direction TB
        ListAgentsSilent[ListAgents Runs Silently<br/>Shows All Available Agents]
        ChangeGoalTool[ChangeGoal Tool Available<br/>Can Switch to ANY Goal]
        NewGoalSelected[User Selects New Goal<br/>e.g., HR, Finance, Travel]
        
        ListAgentsSilent --> ChangeGoalTool
        ChangeGoalTool --> NewGoalSelected
    end
    
    %% Connections
    GoalTools -->|Route 1| Route1
    GoalTools -->|Route 2| Route2
    AutoReturn --> AgentSelection
    ChangeGoalAvailable --> AgentSelection
    NewGoalSelected --> AnyGoal
    
    classDef anyGoal fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef route1 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef route2 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef agentHub fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class AnyGoal anyGoal
    class Route1 route1
    class Route2 route2
    class AgentSelection agentHub
```



---

## **Backend Infrastructure Tools**

YODA's architecture separates **goal-oriented tools** (business logic for customer interactions) from **backend infrastructure tools** (system capabilities like authentication, permissions, alerts). Backend tools are implemented as MCP servers that goal-oriented tools consume, creating a composable microservices architecture where any business tool can leverage system capabilities.

### **Architecture Pattern: Infrastructure as MCP Tools**

```mermaid
graph TD
    subgraph "Goal-Oriented Tools" 
        CustomerMCP["@company/customer-mcp<br/>GetCustomerDetails<br/>UpdateCustomer"]
        FinanceMCP["@company/finance-mcp<br/>TransferMoney<br/>GetBalance"]
        HRMCP["@company/hr-mcp<br/>BookPTO<br/>GetPayroll"]
    end
    
    subgraph "Backend Infrastructure Tools"
        UserMgmtMCP["@yoda/user-management-mcp<br/>AuthenticateUser<br/>ValidatePermissions"]
        AlertsMCP["@yoda/alerts-mcp<br/>CreateAlert<br/>GetUserAlerts"]
        ScheduleMCP["@yoda/scheduler-mcp<br/>CreateSchedule<br/>GetSchedules"]
        NotificationMCP["@yoda/notification-mcp<br/>SendEmail<br/>SendSMS"]
    end
    
    CustomerMCP --> UserMgmtMCP
    CustomerMCP --> AlertsMCP
    FinanceMCP --> UserMgmtMCP
    FinanceMCP --> AlertsMCP
    FinanceMCP --> NotificationMCP
    HRMCP --> UserMgmtMCP
    HRMCP --> ScheduleMCP
    
    UserMgmtMCP --> Database["PostgreSQL<br/>users, sessions, permissions"]
    AlertsMCP --> Database
    ScheduleMCP --> Database
```

### **Benefits of Backend Tool Architecture**

- **üîß Composable Microservices:** Any goal-oriented tool can use any backend capability
- **üéØ Separation of Concerns:** Business logic separate from infrastructure logic
- **‚ôªÔ∏è Reusability:** Backend tools shared across all business domains
- **üß™ Testability:** Each infrastructure capability independently testable
- **üìà Scalability:** Backend tools can be scaled independently based on usage

### **Example: Rich Business Tool Using Backend Infrastructure**

```python
# @company/finance-mcp-server leveraging backend tools
class FinanceMCP:
    def __init__(self):
        self.user_mgmt = MCPClient("@yoda/user-management-mcp")
        self.alerts = MCPClient("@yoda/alerts-mcp")
        self.notifications = MCPClient("@yoda/notification-mcp")
    
    async def transfer_money(self, from_account, to_account, amount, user_id):
        # 1. Validate permissions using backend tool
        has_permission = await self.user_mgmt.validate_permissions(
            user_id=user_id,
            required_scopes=["finance:transfer"]
        )
        
        if not has_permission:
            return {"error": "Insufficient permissions"}
        
        # 2. Business logic
        transfer = await self.execute_transfer(from_account, to_account, amount)
        
        # 3. Create alert using backend tool
        if amount > 10000:
            await self.alerts.create_user_alert(
                user_id=user_id,
                condition=f"Large transfer of ${amount:,.2f} completed",
                alert_type="high_value_transaction"
            )
        
        # 4. Send notification using backend tool
        await self.notifications.send_email(
            user_id=user_id,
            template="transfer_confirmation",
            data={"amount": amount, "to_account": to_account}
        )
        
        return {"transfer_id": transfer.id, "status": "completed"}
```

---

## **User Management & Authentication Flow**

YODA uses a centralized User Management MCP Server to handle authentication, user sessions, permission validation, and tool permission registry. This approach keeps business MCP tools focused on business logic while ensuring secure, user-scoped operations through a single security layer. Goal teams simply specify which tools to include‚Äîpermissions are automatically discovered and validated.

```mermaid
graph TD
    subgraph Frontend ["üåê Frontend (Embedded in Portal)"]
        PortalSession["Portal Session<br/>sessionId: abc123"]
        YodaUI["YODA Chat UI<br/>React Component"]
        PortalSession --> YodaUI
    end
    
    subgraph YODA ["üß† YODA Orchestrator"]
        API["FastAPI<br/>/send-prompt + sessionId"]
        Workflow["AgentGoalWorkflow<br/>stores user_context"]
        UserMgmtActivity["User Management<br/>MCP Activities"]
        
        API --> Workflow
        Workflow --> UserMgmtActivity
    end
    
    subgraph UserMgmtMCP ["üîê User Management MCP Server"]
        AuthTool["AuthenticateUser<br/>sessionId ‚Üí JWT + scopes"]
        PermissionTool["GetToolPermissions<br/>tool ‚Üí required scopes"]
        AccessTool["ValidateUserAccess<br/>check permissions"]
        AlertsTool["GetUserAlerts<br/>user-specific alerts"]
        ScheduleTool["GetUserSchedules<br/>user-specific schedules"]
        Database["PostgreSQL<br/>users, alerts, schedules, tool_permissions"]
        
        AuthTool --> Database
        PermissionTool --> Database
        AccessTool --> Database
        AlertsTool --> Database
        ScheduleTool --> Database
    end
    
    subgraph BusinessMCP ["üè¢ Business MCP Server"]
        CustomerTool["GetCustomerDetails<br/>clean business logic"]
        BusinessAPI["Business API<br/>no JWT handling needed"]
        
        CustomerTool --> BusinessAPI
    end
    
    %% Flow connections
    YodaUI -->|"{ prompt, sessionId }"| API
    UserMgmtActivity --> AuthTool
    AuthTool -->|"user_context"| UserMgmtActivity
    UserMgmtActivity -->|"store user_context"| Workflow
    Workflow -->|"user_context + business_request"| CustomerTool
    UserMgmtActivity --> PermissionTool
    UserMgmtActivity --> AccessTool
    UserMgmtActivity --> AlertsTool
    UserMgmtActivity --> ScheduleTool
    
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef yoda fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef userMgmt fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef business fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class Frontend frontend
    class YODA yoda
    class UserMgmtMCP userMgmt
    class BusinessMCP business
```

**Benefits of Centralized Approach:**

- **üîí Single Security Layer:** All authentication, authorization, and tool permission registry centralized
- **üßπ Clean Business Tools:** Business MCP servers focus purely on business logic  
- **üìä User Context Management:** Alerts, schedules, and permissions managed in one place
- **üîÑ Scalable Architecture:** Easy to add new business tools without security complexity
- **‚ö° Automatic Permission Discovery:** Goal teams just specify tools‚Äîpermissions handled automatically
- **üéØ Tool Team Ownership:** Tool teams define their own permission requirements

**Example Flow:**

**1. User Authentication:**
```json
// YODA calls AuthenticateUser with session
{
  "session_id": "sess_abc123"
}

// Response: Complete user context
{
  "user_id": "user_456",
  "jwt_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "scopes": ["finance:read", "customer:read", "hr:write"],
  "expires_at": "2024-01-15T10:30:00Z"
}
```

**2. Tool Permission Discovery:**
```json
// YODA asks User Management MCP Server what permissions a tool needs
{
  "tool_name": "GetCustomerDetails",
  "mcp_server": "customer-mcp"
}

// Response: Required scopes for this tool
{
  "required_scopes": ["customer:read"],
  "tool_name": "GetCustomerDetails",
  "mcp_server": "customer-mcp"
}
```

**3. Permission Validation:**
```json
// YODA validates if user has required scopes
{
  "user_id": "user_456",
  "user_scopes": ["finance:read", "customer:read", "hr:write"],
  "required_scopes": ["customer:read"]
}

// Response: Authorization check
{
  "authorized": true,
  "missing_scopes": []
}
```

**4. Clean Business Tool Call:**
```json
// Business MCP tool receives clean request (no JWT complexity)
{
  "customer_id": "CUST_123"
}

// Response: Pure business data
{
  "customer_id": "CUST_123",
  "name": "John Smith",
  "email": "john@example.com",
  "status": "active"
}
```



---

## **Alerts & Scheduling Backend Tools**

The alerts and scheduling system exemplifies YODA's backend infrastructure pattern: specialized MCP servers that provide persistent, user-scoped capabilities to any goal-oriented tool. These backend tools manage stateful operations independently while remaining composable across all business domains.

### **Alert Backend Architecture**

**@yoda/alerts-mcp-server** provides persistent user alert capabilities:

```python
# Goal-oriented tools can create sophisticated alerts
await alerts_mcp.create_user_alert(
    user_id="user_456",
    condition="BTC price drops below $50,000 AND portfolio loss > 5%",
    alert_type="financial_risk",
    priority="high"
)

# Backend manages persistent storage and monitoring
{
  "alert_id": "alert_123",
  "user_id": "user_456", 
  "condition": "BTC < $50000 AND portfolio_loss > 0.05",
  "status": "active",
  "created_at": "2024-01-10T09:00:00Z",
  "triggered_at": null
}
```

### **Scheduling Backend Architecture**

**@yoda/scheduler-mcp-server** handles time-based and conditional automation:

```python
# Any business tool can schedule actions
await scheduler_mcp.create_schedule(
    user_id="user_456",
    action="transfer_to_savings",
    condition="monthly",
    action_params={"amount": 500, "target_account": "savings_001"}
)

# Backend manages execution timing and state
{
  "schedule_id": "schedule_789",
  "user_id": "user_456",
  "action": "transfer_to_savings", 
  "condition": "monthly",
  "status": "pending",
  "next_execution": "2024-02-01T00:00:00Z",
  "action_params": {"amount": 500, "target_account": "savings_001"}
}
```

### **Cross-Domain Integration Example**

```python
# HR tool creating finance-related schedule
class HRMCP:
    async def setup_payroll_automation(self, employee_id, salary_amount):
        # Create recurring payroll schedule using backend tool
        await self.scheduler.create_schedule(
            user_id=employee_id,
            action="process_payroll",
            condition="bi_weekly", 
            action_params={
                "amount": salary_amount,
                "employee_id": employee_id,
                "account": "payroll_account"
            }
        )
        
        # Create alert for payroll failures using backend tool
        await self.alerts.create_user_alert(
            user_id=employee_id,
            condition="payroll_failed OR insufficient_funds",
            alert_type="payroll_issue",
            priority="critical"
        )
```


