# YODA Documentation

                                ‚†Ä‚¢Ä‚£†‚£Ñ‚£Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£¥‚£∂‚°æ‚†ø‚†ø‚†ø‚†ø‚¢∑‚£∂‚£¶‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚¢∞‚£ø‚°ü‚†õ‚†õ‚†õ‚†ª‚†ø‚†ø‚¢ø‚£∂‚£∂‚£¶‚£§‚£§‚£Ä‚£Ä‚°Ä‚£Ä‚£¥‚£æ‚°ø‚†ü‚†ã‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†ª‚¢ø‚£∑‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä
                                ‚†Ä‚†ª‚£ø‚£¶‚°Ä‚†Ä‚†â‚†ì‚†∂‚¢¶‚£Ñ‚£Ä‚†â‚†â‚†õ‚†õ‚†ª‚†ø‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚£§‚°Ä‚†Ä‚†Ä‚¢†‚†Ä‚†Ä‚†Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†õ‚¢ª‚£ø
                                ‚†Ä‚†Ä‚†à‚†ª‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†ª‚¢∑‚£∂‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†ô‚¢∑‚°Ä‚†∏‚°á‚†Ä‚£∞‚†á‚†Ä‚¢Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£§‚£§‚£∂‚°∂‚†∂‚†∂‚†í‚†Ç‚†Ä‚†Ä‚£†‚£æ‚†ü
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚°Ñ‚£†‚£¥‚£ø‚£Ø‚£≠‚£Ω‚£∑‚£Ü‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£ø‚£¶‚°Ä‚†Ä‚£†‚£æ‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ü‚†Å‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£∑‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ó‚¢ª‚£ø‚£ß‚£Ω‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚£Ä‚£Ä‚†Ä‚¢†‚£ø‚£ß‚£º‚£ø‚£ø‚£ø‚£ø‚†ó‚†∞‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£∂‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚†É‚†à‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†æ‚£•‚°¨‚†ó‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†Ä‚¢Ä‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£†‚£æ‚°ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†ø‚£∑‚£∂‚£§‚£§‚£Ñ‚£∞‚£Ñ‚†Ä‚†Ä‚†â‚†â‚†â‚†Å‚†Ä‚¢Ä‚£Ä‚£†‚£Ñ‚£Ä‚°Ä‚†Ä‚†â‚†â‚†â‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£•‚£§‚£§‚£§‚£∂‚£∂‚°ø‚†ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢ª‚£ø‚†õ‚¢ø‚£∑‚£¶‚£§‚£¥‚£∂‚£∂‚£¶‚£§‚£§‚£§‚£§‚£¨‚£•‚°¥‚†∂‚†æ‚†ø‚†ø‚†ø‚†ø‚†õ‚¢õ‚£ø‚£ø‚£ø‚£Ø‚°â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ß‚°Ä‚†à‚†â‚†Ä‚†à‚†Å‚£æ‚†õ‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£ø‚†ü‚†â‚£π‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£∏‚£ø‚£ø‚£¶‚£Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£∂‚£ø‚†ã‚£ø‚†õ‚†É‚†Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°ø‚¢ø‚°Ä‚†à‚¢π‚°ø‚†∂‚£∂‚£º‚°á‚†Ä‚¢Ä‚£Ä‚£Ä‚£§‚£¥‚£æ‚†ü‚†ã‚£°‚£ø‚°ü‚†Ä‚¢ª‚£∂‚†∂‚£ø‚£ø‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£∑‚°à‚¢ø‚£¶‚£∏‚†á‚¢Ä‚°ø‚†ø‚†ø‚°ø‚†ø‚†ø‚£ø‚†õ‚†ã‚†Å‚†Ä‚£¥‚†ü‚£ø‚£ß‚°Ä‚†à‚¢Å‚£∞‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚¢ª‚£¶‚£à‚£Ω‚£Ä‚£æ‚†É‚†Ä‚¢∏‚°á‚†Ä‚¢∏‚°á‚†Ä‚¢Ä‚£†‚°æ‚†ã‚¢∞‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†ø‚¢ø‚£ø‚£ø‚°ü‚†õ‚†É‚†Ä‚†Ä‚£æ‚†Ä‚†Ä‚¢∏‚°á‚†ê‚†ø‚†ã‚†Ä‚†Ä‚£ø‚¢ª‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚†Å‚¢Ä‚°¥‚†ã‚†Ä‚£ø‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚°ø‚†ü‚†ã‚†Ä‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£Å‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚°Ä‚†Ä‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£à‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
                                ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†õ‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

## Overview

YODA is a Temporal-powered AI agent system for integrating external business tools via Model Context Protocol (MCP) servers. This document covers MCP integration, team workflows, JWT authentication, goal switching, and persistent alert/schedule systems.

### üß© Architectural Traits

- **[MCP Servers for Tools](#mcp-servers-for-tools):** Modular tools, auto-discovered via NPM
- **[Independent Team Development](#independent-team-development):** Tool and goal teams work in parallel with minimal coordination
- **[Goal Switching Architecture](#goal-switching-architecture):** Users can seamlessly switch between agent personas and goals
- **[Enhanced MCP Tool Discovery](#enhanced-mcp-tool-discovery):** Complete input/output schemas and examples for every tool
- **[JWT-Based Authorization Flow](#jwt-based-authorization-flow):** User access is securely managed with JWT tokens across all tools
- **[Persistent Alerts & Schedules](#persistent-alerts--schedules):** User-specific alerts and schedules are managed as stateful JSON feeds within the orchestrator

---

## MCP Servers for Tools

YODA's architecture is modular by design: YODA itself acts as the orchestrator ("the brain"), while all business logic and integrations are provided by independently developed MCP servers ("the hands"). MCP servers expose tools without needing to know anything about the orchestrator's internals, enabling infinite scalability and rapid, parallel development.

### Tool Registration

1. Add server definition to `shared/mcp_config.py`
2. Reference in goal files 
3. Publish via NPM
4. Tools are auto-discovered at runtime

```mermaid
graph TB
    User["<b>User Input</b>"] --> Frontend["<b>React Frontend</b><br/><i>localhost:5173</i>"]
    Frontend --> API["<b>FastAPI Server</b><br/><i>localhost:8000</i>"]
    API --> Temporal["<b>Temporal Server</b><br/><i>localhost:7233</i>"]
    
    subgraph YodaBrain ["üß† <b>YODA - The Orchestrator Brain</b>"]
        Temporal --> Worker["<b>Temporal Worker</b>"]
        Worker --> AgentWorkflow["<b>AgentGoalWorkflow</b><br/><i>workflows/agent_goal_workflow.py</i>"]
        AgentWorkflow --> LLMActivity["<b>LLM Activities</b><br/><i>activities/tool_activities.py</i>"]
        AgentWorkflow --> MCPClientManager["<b>MCP Client Manager</b><br/><i>shared/mcp_client_manager.py</i>"]
        MCPClientManager --> RuntimeDiscovery["<b>Runtime Tool Discovery</b><br/><i>mcp_list_tools activity</i>"]
    end
    
    subgraph ExternalMCP ["üåê <b>External MCP Ecosystem</b>"]
        BusinessAPI["<b>Business API</b><br/><i>npx @company/business-mcp</i>"]
        AnalyticsService["<b>Analytics Service</b><br/><i>npx @company/analytics-mcp</i>"]
        IntegrationHub["<b>Integration Hub</b><br/><i>npx @company/integration-mcp</i>"]
    end
    
    subgraph Infrastructure ["üèóÔ∏è <b>Infrastructure</b>"]
        Postgres[("<b>PostgreSQL</b><br/><i>Temporal Persistence</i>")]
        NPMRegistry[("<b>NPM Registry</b><br/><i>MCP Package Distribution</i>")]
    end
    
    %% Connections
    MCPClientManager --> BusinessAPI
    MCPClientManager --> AnalyticsService  
    MCPClientManager --> IntegrationHub
    BusinessAPI -.->|Discovery| RuntimeDiscovery
    AnalyticsService -.->|Discovery| RuntimeDiscovery
    IntegrationHub -.->|Discovery| RuntimeDiscovery
    Temporal --> Postgres
    ExternalMCP --> NPMRegistry
    
    classDef brain fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef infra fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class YodaBrain brain
    class ExternalMCP external
    class Infrastructure infra
```

## **Independent Team Development**

Tool teams build and maintain MCP servers; goal teams design agent experiences. Tools are automatically discovered‚Äîadding a new tool is as simple as registering a new MCP server endpoint, with no redeployment or deep integration required.

### **üõ†Ô∏è Tool Development Team**

**Responsibility**: Build and maintain MCP servers, develop business tools, ensure API integrations

**Process**: Create MCP servers with proper tool schemas and publish to NPM
```bash
# 1. Build MCP Server following MCP protocol standard
# Node.js, Python, Go, etc. - any language that can create NPM executable

# 2. Develop tools with correct schema (automatically validated)
{
  "name": "GetCustomerOrders",
  "description": "Retrieve customer order history",
  "inputSchema": {
    "type": "object",
    "properties": {
      "customer_id": {"type": "string", "description": "Customer identifier"},
      "date_range": {"type": "string", "description": "Date range filter"}
    },
    "required": ["customer_id"]
  }
}

# 3. Publish to NPM
npm publish @company/business-mcp

# 4. Notify goal team
"Hey, we added @company/business-mcp with order management and customer tools"
```

---

### **üé® Goal Team** (Agent Design & User Experience Focus)

**Responsibility**: Agent personas, conversation flows, user experience

**Process**: Discover MCP tools and design agents
```python
# Step 1: Add MCP server definition to shared/mcp_config.py
def get_business_mcp_server_definition(included_tools: list[str]) -> MCPServerDefinition:
    return MCPServerDefinition(
        name="business-mcp",
        command="npx",
        args=["-y", "@company/business-mcp"],
        included_tools=included_tools,
    )

# Step 2: Tools are automatically discovered at runtime via mcp_list_tools
# Returns schema like:
{
  "GetCustomerOrders": {
    "name": "GetCustomerOrders",
    "description": "Retrieve customer order history", 
    "inputSchema": {
      "properties": {
        "customer_id": {"type": "string", "description": "Customer identifier"},
        "date_range": {"type": "string", "description": "Date range filter"}
      },
      "required": ["customer_id"]
    }
  }
}

# Step 3: Design goals using MCP server reference
# goals/business.py - Focus on agent behavior and UX  
goal_business_assistant = AgentGoal(
    agent_name="Business Assistant",
    agent_friendly_description="Help with customer orders and business operations",
    starter_prompt="Hi! I can help with your business operations...",
    
    # Reference MCP server (tools auto-discovered at runtime)
    mcp_server_definition=get_business_mcp_server_definition(
        included_tools=["GetCustomerOrders", "UpdateOrderStatus"]
    ),
)
```

---

## **Goal Switching Architecture**

Original Temporal supports both single-agent and multi-agent modes, but YODA defaults to multi-goal mode‚Äîenabling agent orchestration and fully realizing the MCP framework.

```mermaid
graph TD
    subgraph AnyGoal ["Any Active Goal (Travel, HR, Finance, etc.)"]
        direction TB
        UserInGoal[User in Middle of Goal<br/>e.g., Booking Flights]
        GoalTools[Goal-Specific Tools<br/>+ ListAgents tool<br/>auto-added in multi-goal mode]
        
        UserInGoal --> GoalTools
    end
    
    subgraph TwoEscapeRoutes ["Two Escape Routes from Any Goal"]
        direction TB
        
        subgraph Route1 ["Route 1: Natural Completion"]
            direction TB
            CompleteAllSteps[Complete ALL Goal Steps<br/>e.g., Search ‚Üí Book ‚Üí Invoice]
            SystemTrigger[System Triggers<br/>'pick-new-goal']
            AutoReturn[Auto-Return to<br/>goal_choose_agent_type]
            
            CompleteAllSteps --> SystemTrigger
            SystemTrigger --> AutoReturn
        end
        
        subgraph Route2 ["Route 2: Instant Switch"]
            direction TB
            UserCallsListAgents[User Calls ListAgents<br/>from any goal]
            InstantJump[Instant Jump to<br/>goal_choose_agent_type]
            ChangeGoalAvailable[ChangeGoal Tool<br/>Now Available]
            
            UserCallsListAgents --> InstantJump
            InstantJump --> ChangeGoalAvailable
        end
    end
    
    subgraph AgentSelection ["Agent Selection Hub (goal_choose_agent_type)"]
        direction TB
        ListAgentsSilent[ListAgents Runs Silently<br/>Shows All Available Agents]
        ChangeGoalTool[ChangeGoal Tool Available<br/>Can Switch to ANY Goal]
        NewGoalSelected[User Selects New Goal<br/>e.g., HR, Finance, Travel]
        
        ListAgentsSilent --> ChangeGoalTool
        ChangeGoalTool --> NewGoalSelected
    end
    
    %% Connections
    GoalTools -->|Route 1| Route1
    GoalTools -->|Route 2| Route2
    AutoReturn --> AgentSelection
    ChangeGoalAvailable --> AgentSelection
    NewGoalSelected --> AnyGoal
    
    classDef anyGoal fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef route1 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef route2 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef agentHub fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class AnyGoal anyGoal
    class Route1 route1
    class Route2 route2
    class AgentSelection agentHub
```

---

## **Enhanced MCP Tool Discovery**

The MCP protocol requires servers to define an `inputSchema` for each tool, which forces goal teams to guess tool response formats. YODA enhances this by extending the MCP server contract: MCP servers must also provide a `responseSchema` and `examples`, ensuring goal teams have complete input and output details for accurate agent design.

**Enhanced MCP Schema:**

```python
# MCP Server: @company/auth-mcp
{
  "name": "ValidateJWT",
  "description": "Validate user JWT token and extract permissions",
  "inputSchema": {
    "type": "object",
    "properties": {
      "jwt_token": {"type": "string", "description": "User JWT token"}
    },
    "required": ["jwt_token"]
  },
  "responseSchema": {
    "type": "object", 
    "properties": {
      "valid": {"type": "boolean"},
      "user_id": {"type": "string"},
      "scopes": {"type": "array", "items": {"type": "string"}},
      "expires_at": {"type": "string", "format": "date-time"}
    }
  },
  "examples": {
    "success": {
      "valid": true,
      "user_id": "user_123", 
      "scopes": ["finance:read", "hr:write"],
      "expires_at": "2024-01-15T10:30:00Z"
    },
    "error": {
      "valid": false,
      "error": "Token expired"
    }
  }
}
```

**Impact for Goal Teams:**

Goal teams see precise response structures and concrete examples, eliminating guesswork and the need to manually write example responses in `example_conversation_history`.

_Current example_conversation_history approach:_
```python
example_conversation_history="\n ".join([
    "user_confirmed_tool_run: <user clicks confirm on ValidateJWT tool>",
    "tool_result: { 'valid': true, 'user_id': 'user_123' }",  # Manual writing
    "agent: Your token is valid!"
])
```

---

## **JWT-Based Authorization Flow**

YODA uses JWT-based authorization to securely connect user sessions with business tools. The system retrieves JWT tokens from an Auth MCP server using the user's session ID, then passes these tokens to business MCP servers, which validate the tokens and scopes before executing any tool‚Äîensuring each user can only access authorized tools and data.

```mermaid
graph TD
    subgraph Frontend ["üåê Frontend (Embedded in Portal)"]
        PortalSession["Portal Session<br/>sessionId: abc123"]
        YodaUI["YODA Chat UI<br/>React Component"]
        PortalSession --> YodaUI
    end
    
    subgraph YODA ["üß† YODA System"]
        API["FastAPI<br/>/send-prompt"]
        Workflow["AgentGoalWorkflow<br/>session_context: abc123"]
        JWTActivity["MCP Activity<br/>GetJWTFromSession"]
        
        API --> Workflow
        Workflow --> JWTActivity
    end
    
    subgraph AuthMCP ["üîê Auth MCP Server"]
        GetJWTTool["GetJWTFromSession<br/>MCP Tool"]
        PortalAPI["Portal API Call<br/>GET /api/session/abc123"]
        
        JWTActivity --> GetJWTTool
        GetJWTTool --> PortalAPI
    end
    
    subgraph BusinessMCP ["üè¢ Business MCP Server"]
        CustomerTool["GetCustomerOrders<br/>Requires JWT"]
        BusinessAPI["Business API<br/>Authorization: Bearer jwt_token"]
        
        CustomerTool --> BusinessAPI
    end
    
    %% JWT Flow
    YodaUI -->|"{ prompt, sessionId }"| API
    PortalAPI -->|"{ jwt_token, user_id, scopes }"| GetJWTTool
    GetJWTTool -->|"JWT Response"| JWTActivity
    JWTActivity -->|"Store JWT"| Workflow
    Workflow -->|"Pass JWT to tools"| CustomerTool
    
    classDef frontend fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef yoda fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef auth fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef business fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class Frontend frontend
    class YODA yoda
    class AuthMCP auth
    class BusinessMCP business
```



**Example JWT Flow:**

**1. Auth MCP Response:**
```json
{
  "jwt_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user_id": "user_123",
  "scopes": ["csr", "ops", "sales"],
  "expires_at": "2024-01-15T10:30:00Z"
}
```

**2. Business MCP Tool Request (with JWT):**
```json
{
  "date_range": "2024-01-01,2024-01-31",
  "jwt_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."  // jwt_token includes customer_id
}
```



---

## **Persistent Alerts & Schedules**

YODA manages persistent alerts and schedules as stateful JSON feeds, linked to user JWT tokens and stored within the orchestration engine. This design ensures user-specific automation and notifications are reliably maintained across all integrated business tools.

**Database Extension:**
Add alerts and schedules tables to existing PostgreSQL (Temporal persistence database):

```sql
-- User alerts/schedules identified by JWT token
alerts_table: user_id, condition, status (active/triggered/dismissed), created_at
schedules_table: user_id, action, condition, status (pending/executed/failed), created_at
```

**Frontend Enhancement:**
Add notification area above the chat interface.

**JSON Feed Structure:**

```json
// Alerts table feed
{
  "alerts": [
    {"condition": "BTC drops 5%", "status": "active", "created_at": "2024-01-15"},
    {"condition": "Unpaid fee $50", "status": "triggered", "created_at": "2024-01-10"}
  ]
}

// Schedules table feed  
{
  "schedules": [
    {"action": "Sell BTC", "condition": "BTC rises 5%", "status": "pending", "created_at": "2024-01-15"},
    {"action": "Monthly report", "condition": "1st of month", "status": "executed", "created_at": "2024-01-01"}
  ]
}
```

**Status Types:**
- **Alerts:** `active`, `triggered`, `dismissed`
- **Schedules:** `pending`, `executed`, `failed`
